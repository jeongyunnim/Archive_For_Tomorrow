---
날짜: 2024-12-14
넘버: 
태그: 프로그래밍
저자: 김영한
출처: https://www.inflearn.com/course/ORM-JPA-Basic/dashboard
aliases:
---
### 날짜:  2024-12-14 18:43

### 태그: #프로그래밍 #자바 #스프링

>[!메모]
>

### 원문
---
# 6.3 일대일 1:1
- 주 테이블과 대상 테이블에 모두 외래키를 넣을 수 있다.
- 외래키에 데이터베이스 **UNIQUE 조건**이 추가되어야 한다.
## 주 테이블 외래키 단방향
- LOCKER_ID에 UNIQUE 제약 조건을 걸어주면 1대1 연관관계를 만족시킬 수 있다.
- `@ManyToOne`과 동일하다.
![[Excalidraw/Java JPA.md#^group=TkBNNY_0v-hK7KaPAhMiU]]

## 양방향
- Locker 객체에 Member member를 추가하여 mappedBy를 설정해주면 1:1 양방향 매핑을 할 수 있다.

## 정리
- N:1과 마찬가지로, FK가 있는 곳이 연관관계의 주인이다.

> [!tip] 대상 테이블을 연관관계의 주인으로 두는 것
> 대상 테이블을 연관관계의 주인으로 단방향 매핑은 불가능하다.
> DBA 입장에서 보면 DB상에서 Locker가 Member의 FK를 가지도록 구성하는 것이 장기적으로 유리할 수 있다(멤버가 Locker를 여러 개 가질 수 있게되는 요구사항의 변화 등).
> 하지만 객체를 구현하는 프로그래머 입장에서는 Member가 Locker의 FK를 가지도록 하는 것이 성능 상 이점을 가질 수 있다.

### 주 테이블에 외래 키
- 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 FK를 두고 대상 테이블을 찾는다.
- 객체지향 개발자들이 주로 선호하는 방향
- JPA 매핑이 편리하다.
- **장점**: 주 테이블만 조회하면 대상 테이블의 데이터가 있는지 확인할 수 있다.
- **단점**: 값이 없으면 외래키에 NULL을 허용하게 된다.
### 대상 테이블에 외래 키
- 대상 테이블에 FK가 존재
- 전통적인 데이터베이스 개발자가 주로 선호하는 방향
- **장점**: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조를 유지할 수 있다.
- **단점**: 프록시 기능의 한계로 지연로딩으로 설정해도 항상 즉시 로딩된다.
	- Member의 테이블만 조회해서 Locker의 존재를 파악할 수 없으므로, Locker 테이블에서 Where문을 통해 Member가 있는지 없는지 찾는 과정이 필요하다.
	- 이미 Locker를 조회한 뒤 Member 객체의 Locker를 넣어주기 때문에 Locker를 프록시 개체로 만들 필요도 없고, 떄문에 지연로딩이 아무런 의미가 없어 하이버네이트는 해당 부분을 항상 즉시로딩 하도록 구현되어있다.




---
### 생각(파생된 질문/생각)

### 출처
- [자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)

### 연결 문서 (연결 이유)
