---
날짜: 2024-08-25
넘버: 
태그: 프로그래밍
저자: Eazy Bytes
출처: https://www.udemy.com/course/master-microservices-with-springboot-docker-kubernetes-korean/
aliases:
---
### 날짜:  2024-08-25 16:02

### 태그: #프로그래밍 #자바 #스프링

>[!메모]
>

### 원문
---
# 리소스 서버로서의 게이트웨이 보안
### 의존성 추가
```java
implementation 'org.springframework.boot:spring-boot-starter-security'  
implementation 'org.springframework.security:spring-security-oauth2-resource-server'  
implementation 'org.springframework.security:spring-security-oauth2-jose'
```
### 소스코드
- `config/SecurityConfig` 클래스 생성
```java
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity serverHttpSecurity) {
        serverHttpSecurity.authorizeExchange(exchanges -> exchanges.pathMatchers(HttpMethod.GET).permitAll()
                .pathMatchers("/eazybank/accounts/**").authenticated()
                .pathMatchers("/eazybank/loans/**").authenticated()
                .pathMatchers("/eazybank/cards/**").authenticated())
                .oauth2ResourceServer(oAuth2ResourceServerSpec -> oAuth2ResourceServerSpec
                        .jwt(Customizer.withDefaults()));
        serverHttpSecurity.csrf(ServerHttpSecurity.CsrfSpec::disable);
        return serverHttpSecurity.build();
    }

}
```
- spring reactive module을 기반으로 구축되었으므로, `@EnableWebFluxSecurity`를 사용해야 한다.
- 어떤 요청이든 인증해야 한다는 의미이다.
	- `permitAll()`을 사용하면 모든 요청을 허용한다.
- 첫 번째 구성이 GET을 허용하도록 했으므로, 가장 높은 우선순위를 가진다.
	- 왜 `,`로 path를 전달하지 않고 람다 형식으로 기술했는가? 다음 강의에서 그 이유가 밝혀진다.
- 브라우저와 관련된 경우에만 csrf 보호가 필요하기 때문에 비활성화 해야한다.
### 설정
```json
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: "http://localhost:7080/realms/master/protocol/openid-connect/certs"
```
- [[11.5 KeyCloak을 이용하여 인증 서버 설정하기#인증 서버에 연결하여 Access 토큰 얻기|JWT endpoint url]]
- 이 URL에서는 무엇을 하는가?
	- 리소스 서버와 연결하고 키클락 서버에서 공개 인증서를 다운로드 한다.
- 공개 인증서란?
	- 공개 인증서를 사용하여 리소스 서버는 주어진 액세스 토큰이 실제로 키클락 서버에서 발급한 것인지 확인할 수 있다.
	- 키클락에는 개인 인증서가 있다.
	- 개인 인증서를 사용하면 새로운 토큰만 발급할 수 있다.
## role을 사용하여 게이트웨이 서버 인가 구현하기
- 위의 시나리오에서는 애플리케이션이 인증되었는지만 확인하고 있다.
- 클라이언트 애플리케이션에 role, authorities, privileges에 따라 요청을 처리할 수 있어야 한다.
	- `hasRole`메서드를 통해 클라이언트가 인증 서버 내부에서 구성해야 하는 역할을 전달할 수 있다.
### 소스코드
```java
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity serverHttpSecurity) {
	serverHttpSecurity.authorizeExchange(exchanges -> exchanges.pathMatchers(HttpMethod.GET).permitAll()
			.pathMatchers("/eazybank/accounts/**").hasRole("ACCOUNTS")
			.pathMatchers("/eazybank/loans/**").hasRole("LOANS")
			.pathMatchers("/eazybank/cards/**").hasRole("CARDS"))
			.oauth2ResourceServer(oAuth2ResourceServerSpec -> oAuth2ResourceServerSpec
					.jwt(Customizer.withDefaults()));
	serverHttpSecurity.csrf(ServerHttpSecurity.CsrfSpec::disable);
	return serverHttpSecurity.build();
}
```
- authenticated 대신 hasRole을 통해 role을 검사하도록 설정한다.
### 키클록 설정
- `Clients/CreateRoles`에서 ACCOUNTS를 생성한다.
- `Service accounts roles`에서 Account 를 Assign 한다.
![[Pasted image 20240826205802.png]]
- postman을 통해 Access 토큰을 디코딩 하면 해당 항목이 추가된 것을 확인할 수 있다.
```json
...
"resource_access": {
  "jeseo-callcenter-cc": {
    "roles": [
	  "ACCOUNTS"
    ]
  }
...
```


---
### 생각(파생된 질문/생각)

### 출처
- [유데미 - Java, Spring Boot, Spring Cloud, Docker, Kubernetes, Helm, 마이크로서비스 보안](https://www.udemy.com/course/master-microservices-with-springboot-docker-kubernetes-korean/)

### 연결 문서 (연결 이유)
