---
날짜: 2024-08-29
넘버: 
태그: 프로그래밍
저자: Eazy Bytes
출처: https://www.udemy.com/course/master-microservices-with-springboot-docker-kubernetes-korean/
aliases:
---
### 날짜:  2024-08-29 01:02

### 태그: #프로그래밍 #자바 #스프링

>[!메모]
>

### 원문
---
# Event-driven 마이크로서비스
## 해결해야 할 문제
### temporal coupling을 어떻게 회피할 것인가?
- temporal coupling: 시간적 결합
- loose coupling: 느슨한 결합
	- 애플리케이션의 비즈니스 로직을 별도의 마이크로서비스로 분리하여 독립적으로 개발, 배포, 확장 하도록 구성했다.
#### temporal coupling이 무엇인가?
- 호출된 서비스가 작업을 수행하기 위해 호출하는 서비스의 즉각적인 응답을 기대할 때 발생한다.
	- 서비스1이 서비스2를 호출하여 처리하는 작업의 경우 2의 작업이 끝날 때까지 대기하게 된다.
	- 이를 서비스1과 서비스2가 시간적인 결합을 갖고있다고 표현한다.
- 이러한 종속성에 따른 시간적 결합은 한 서비스의 성능 저하가 모든 서비스에 영향을 미칠 우려가 생기게 된다.
#### 어떻게 해결할 것인가?
- 마이크로서비스 네트워크는 가능한 한 비동기 통신을 사용해야 한다.
### 동기 통신
- 동기 통신의 두 가지 접근 방식
	- imperative 접근 방식
	- reactive 접근 방식
- imperative 접근 방식
	- 서비스 1이 서비스 2를 호출할 때 통신 전용 스레드가 할당되고 이 작업은 block 되며 서비스 2가 응답을 할 때까지 대기한다.
- reactive 접근 방식
	- 서비스 2의 응답을 기다리는 스레드는 block되지 않는다.
	- 호출이 끝나면 스레드는 스레드 풀로 돌아가 다음 요청을 위해 대기한다.
	- 서비스 2의 응답이 오면 스레드 풀의 스레드가 할당된다.
- 이 두 가지 접근 방식은 동기식 통신이다.
	- 서비스 1은 서비스 2의 응답을 받을 때까지 비즈니스 로직을 처리하지 않기 때문이다.
	- 사용자에게 즉각적인 응답을 보여주려는 비즈니스 시나리오에 필요할 수 있다.
		- 통장의 잔액을 보여주는 기능 등
- 하지만 모든 유형의 시나리오에 동기식 통신을 사용하면 안 된다.
### 비동기 통신을 구축하는 방법
- 이벤트 기반 마이크로서비스를 구축해야 한다.
	- event driven microservice
- 이벤트란?
	- 마이크로서비스 내부에서 발생하는 사건
	- 시스템 내부의 상태 전환 또는 업데이트
- 이벤트가 발생할 때마다 관련된 당사자에게 알려야 한다.
	- 쇼핑몰의 시나리오에서 주문이 들어오면 주문 마이크로서비스에서 처리를 하고 배송 마이크로서비스에 알림을 보내야 한다.
	- 이러한 서비스 간의 통신은 동기식 통신일 필요가 없다.
	- 사용자가 결제하고 주문이 확인되면 주문 마이크로서비스가 배송 마이크로서비스에게 이벤트를 생성하거나 알림을 트리거 하기만 하면 된다.
- 서비스들 간의 통신은 이벤트를 통해 비동기적으로 진행된다.
## Event-driven 모델
- 2가지 모델
	- publisher/subscriber(pub/sub) 모델
	- streaming 모델
### publisher/subscriber 모델
- 구독을 중심으로 이루어진다.
- publisher가 이벤트를 생성하고 이 이벤트에 관심있는 subscriber에게 배포하여 소비하도록 한다.
- subscriber가 이벤트를 소비한 후에는 다시 불러올 수 없다.
- 또한 나중에 참여한 신규 구독자는 과거 이벤트에 액세스할 수 없다.
### Streaming 모델
- producer는 이벤트를 생산하고 소비자는 이벤트를 소비한다.
#### pub/sub 모델과의 차이점
- streaming 모델은 이벤트가 순차적으로 로그에 기록된다.
- 생산자는 이벤트가 발생하면 이벤트를 publish 하고 이 이벤트들은 잘 정렬되어 저장된다.
- 소비자인 클라이언트는 이벤트 스트림의 어느 부분이든 읽을 수 있다.
	- 언제든지 과거 이벤트에 다시 접근할 수 있다.
	- 신규 구독자 또한 과거 이벤트에 접근할 수 있다.
### 어떤 모델을 사용할 것인가?
- 과거 이벤트를 접근할 수 있도록 할 것인지에 따라 다르다.
	- 소비자가 과거 이벤트를 읽지 않을 것이라면 pub/sub 모델
	- 과거 이벤트를 읽거나 다시 트리거 해야한다면 streaming 모델
		- 유연성을 제공하려는 목적
- Streaming 모델을 선택하더라도 이벤트 replay 기능을 비활성화 할 수 있기 때문에 비즈니스 모델에 따라 적절하게 선택하면 된다.
	- 어느 하나가 특히 더 좋거나 하지 않다.
### RabbitMQ 와 Kafka
- pub/sub 모델을 구현할 때 RabbitMQ를 사용하는 경우가 많다.
- Event streaming 모델을 구현할 때 Kafka를 사용하는 경우가 많다.

---
### 생각(파생된 질문/생각)

### 출처
- [유데미 - Java, Spring Boot, Spring Cloud, Docker, Kubernetes, Helm, 마이크로서비스 보안](https://www.udemy.com/course/master-microservices-with-springboot-docker-kubernetes-korean/)

### 연결 문서 (연결 이유)
