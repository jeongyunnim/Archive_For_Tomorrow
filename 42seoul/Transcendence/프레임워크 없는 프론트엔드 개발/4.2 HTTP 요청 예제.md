---
날짜: 2024-02-26
넘버: 
태그: 프로그래밍
출처: 프레임워크 없는 프론트엔드 개발
aliases: 
저자: 프란세스코 스트라츨로
---
### 날짜  2024-02-16 19:05

### 태그:

>[!메모]
>

### 원문
---
# HTTP 요청 예제
- XMLHttpRequest, Fetch, axios
## 기본 구조
### 간단한 html
```html
<html>

<body>
	<button data-list>Read Todos</button>
	<button data-add>Add Todos</button>
	<button data-update>Update Todos</button>
	<button data-delete>Delete Todos</button>
	<div></div>
</body>

</html>
```
### HTTP 클라이언트 애플리케이션 메인 컨트롤러
```js
import todos from './todos.js'

const NEW_TODO_TEXT = 'A simple todo Element';

const printResult = (action, result) => {
	const time = (new Date()).toTimeString();
	const node = document.createElement("p");  
	node.textContent = `${action.toUpperCase()}: ${JSON.stringify(  
		result
	)} (${time})`;
	document.querySelctor("div").appendChild(node)
}

const onListClick = async () => {  
	const result = await todos.list();  
	printResult("list todos", result);  
};  
  
const onUpdateClick = async () => {  
	const list = await todos.list();  
	const { id } = list[0];  
	const newTodo = {  
		id,  
		completed: true,  
	};  
	const result = await todos.update(newTodo);  
	printResult("update todo", result);  
};

const onDeleteClick = async () => {  
	const list = await todos.list();  
	const { id } = list[0];  
	
	const result = await todos.delete(id);  
	printResult("delete todo", result);  
};
  
document  
	.querySelector("button[data-list]")  
	.addEventListener("click", onListClick);  

document  
	.querySelector("button[data-add]")  
	.addEventListener("click", onAddClick);  
  
document  
	.querySelector("button[data-update]")  
	.addEventListener("click", onUpdateClick);  
  
document  
	.querySelector("button[data-delete]")  
	.addEventListener("click", onDeleteClick);
```
- HTTP 클라이언트를 직접 사용하는 대신 HTTP 요청을 todos 모델 객체에 래핑했다.
	- 테스트 가능성
		- todo 객체를 정적 데이터 세트(**fixture**)를 반환하는 목mock으로 바꿀 수 있다.
		- 컨트롤러를 독립적으로 테스트할 수 있다.
	- 가독성
		- 모델 객체는 코드를 더 명확하게 한다.
> 컨트롤러에서 HTTP 클라이언트를 직접 사용하지 않는다. 이런 함수는 모델 객체에서 캡슐화하는 것이 좋다.
### todo 모델 객체
```js
import http from './http.js'

const HEADERS = {
	'Content-Type': 'application/json'
}

const BASE_URL = '/api/todos'

const list = () => http.get(BASE_URL)

const create = text => {
	const todo = {
		text,
		completed: false
	}
	return http.post(
		BASE_URL,
		todo,
		HEADERS
	)
}

const update = newTodo => {
	const url = `${BASE_URL}/${newTodo.id}`
	return http.patch(
		url,
		newTodo,
		HEADERS
	)
}

const deleteTodo = id => {
	const url = `${BASE_URL}/${id}`
	return http.delete(
		url,
		HEADERS
	)
}

export default {
	list,
	create,
	update,
	delete: deleteTodo
}
```
- [[HTTP 클라이언트의 서명]]은 GET이나 DELETE 같이 본문이 필요 없는 메서드의 경우
	- http\[verb](url, config)
- 나머지 메서드
	- http\[verb](url, body, config)
- HTTP클라이언트에 반드시 공개 API를 사용해야 하는 것은 아니다.
	- 하지만 어떤 방법이든 일관성을 유지하는 것이 좋다.
## XMLHttpRequest
- W3C가 비동기 HTTP 요청의 표준 방법을 정의한 첫 번째 시도였다.
```js
const setHeaders = (xhr, headers) => {
	Object.entries(headers).forEach(entry => {
		const [name, value] = entry;

		xhr.setRequestHeader(name, value)
	});
};

const parseResponse = xhr => {
	const { status, responseText } = xhr;

	let data
	if (status !== 204) {
		data = JSON.parse(responseText);
	}

	return {
		status,
		data
	}
}

const request = params = {
	return new Promise((resolve, reject) => {
		const xhr = new XMLHttpRequest();

		const {
			method = 'GET',
			url,
			headers = {},
			body
		} = params;

		xhr.open(method, url);

		setHeaders(xhr, headers);

		xhr.send(JSON.stringify(body));

		xhr.onerror = () => {
			reject(new Error('HTTP Error'));
		}
		xhr.ontimeout = () => {
			reject(new Error('Timeout Error'));
		}
			xhr.onload = () => resovle(parseResponse(xhr));
	})
}

const get = async (url, headers) => {
	const response = await request({
		url,
		headers,
		method: 'GET'
	});

	return response.data;
}

const post = async (url, body, headers) => {
	const response = await request({
		url,
		headers,
		method: 'POST',
		body
	});

	return response.data;
}

const patch = async (url, body, headers) => {
	const response = await request({
		url,
		headers,
		method: 'PATCH',
		body
	});

	return response.data;
}

const deleteRequest = async (url, headers) => {
	const response = await request({
		url,
		headers,
		method: 'DELETE'
	});

	return response.data;
}

export default {
	get,
	post,
	put,
	patch,
	delete, deleteRequest
}
```

---
### 생각(파생된 질문/생각)

### 출처

### 연결 문서 (연결 이유)

