---
날짜: '"2024-01-24"'
넘버: 
태그: 프로그래밍
출처: JavaScript 완벽 가이드
강사: Maximilian Schwarzmuller
aliases:
---
### 날짜  2024-01-24 20:48

### 태그: #프로그래밍 

>[!메모]
> 배열을 생성하는 방법
> 배열을 다루는 방법
> 배열 메서드
> map과 set

### 원문
---
# Array & Iterable
## 반복이란 무엇인가?
- 기술적으로는 iterable 프로토콜로 구현되었으며 itrator 메서드를 가진 객체.
- **for-of**를 사용할 수 있는 객체
- 모든 배열은 iterable 하지만, itarable한 객체가 모두 배열인 것은 아니다.
	- 노드 리스트
	- map 
	- set
## 유사 배열 객체란 무엇인가?
: Array-like Object
- 길이 프로퍼티가 있고, 아이템에 접근하기 위해 index를 사용하는 객체.
	- 노드 리스트
	- 문자열
## 배열
### 배열 생성 방법
```js
// 일반적인 배열 생성 방식
const array = [1, 2, 3];
// 5칸 짜리 빈 배열
const array = new Array(5);
// 1, 2, 3을 요소로 가진 배열
const array = new Array(5);
// 1, 2, 3을 요소로 가진 배열 (new를 안 써도 된다)
const array = Array(1, 2, 3);
// 전역에서 사용 가능한 배열 객체데 대한 메서드
const array = Array.of(1, 2);
// 이터러블이나 유사 배열 객체를 변환해준다. -> 유사 배열 객체를 배열의 메서드를 사용할 수 있게 만들어준다.
const array = Array.From(`${이터러블}`);
```
### 배열에 들어가는 요소
```js
const listItems = document.querySelector('li');
const arrayListItems = Array.from(listItems);
const hobbies = ['Cooking', 'Sports'];
// 자료가 혼합된 배열도 생성 가능
const personalData = [30, 'Max', {moreDetail: []}];
// 배열을 요소로 가지는 다차원 배열 생성 가능
const analyticsData = [[1, 1.6], [-5.4, 2.1]];
```
- 저장하는 값에 대해서는 매우 유연하다.
	- 다차원 배열을 순회할 때, 배열 객체 이외의 요소가 들어있을 경우 에러가 발생할 수 있다.
![[Pasted image 20240125150334.png]]
### 배열 양 끝에서 요소 추가 제거
```js
const hobbies = ['Sports', 'Cooking'];
hobbies.push('Reading'); // Sports, Cooking, Reading
hobbies.unshift('Coding'); // Coding, Sports, Cooking, Reading
const poppedValue = hobbies.pop(); // Coding, Sports, Cooking
hobbies.shift(); // Sports, Cooking
```
- `unshift()`와 `shift()`
	- 모든 요소를 이동시키기 때문에 `push()`, `pop()`보다 느리다.
	- shift 연산은 요소를 왼쪽으로 밀게 되고, unshift 연산은 오른쪽으로 당기게 되어 각각 **첫 번째 요소 삭제/추가**를 한다.
- [[SparseArray]]
	- https://www.geeksforgeeks.org/what-is-meant-by-sparse-array/
```js
hobbies[10] = 'Coding';
// 0, 1 ... 10 -> 빈 요소로 채워진다.
```
### 만능 배열 메서드 splice()
- 이터러블이나 유사 배열 객체에서는 사용할 수 없다.
	- Array.from()을 통해 배열로 전환한 후 사용해야 한다.
- 두 요소 사이에 추가
```js
hobbies.splice(0, 1); // 0번째 인덱스부터 1개를 삭제 
hobbies.splice(0, 0, 'Good Food'); // 0번째 인덱스에 'Good Food'삽입
const removedElement = hobbies.splice(1, 3); // 삭제한 요소를 반환해준다.
```
- 음수 인덱싱이 가능하다.
	- `hobbies[-1]`는 사용할 수 없지만 `hobbies.splice(-1,1)`은 사용할 수 있다.
### 배열을 복사해주는 slice()
```js
const testResult = [3, 1.5, 10, 99.99];
const storedResult = testResult;
```
- 얕은 복사: 주소값만 복사해옴.
	- testResult를 수정하면 storedResult에서도 수정된 사항이 반영되어 있음.
```js
const testResult = [3, 1.5, 10, 99.99];
const storedResult = testResult.slice();
```
- 깊은 복사
	- 해당 배열의 요소를 가진 새 배열이 생성된다.
- 범위를 지정하여 `slice()`하기
	- 끝 인덱스는 포함하지 않는다.
```js
const testResult = [3, 1.5, 10, 99.99];
const storedResult = testResult.slice(1, 3);
console.log(storedResult); // 1.5(testResult[1]), 10(testResult[2])
```
- 인자를 하나만 넣을 경우 해당 인덱스부터 끝 요소까지 가져온다.
```js
const testResult = [3, 1.5, 10, 99.99];
const storedResult = testResult.slice(2);
console.log(storedResult); // 10, 99.99
```
### 배열을 연결해주는 concat()
```js
const testResults = [3, 1.5, 10, 99.99];
const storedResults = testResults.concat([11.11, 2]);
console.log(storedResult); // 3, 1.5, 10, 99.99, 11.11, 2
```

---
### 생각(파생된 질문/생각)

### 출처

### 연결 문서 (연결 이유)
