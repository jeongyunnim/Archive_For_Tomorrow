---
날짜: 2025-01-22
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 김유진
aliases:
---
### 날짜:  2025-01-22 09:01

### 태그: #프로그래밍/임베디드

>[!메모]
> 터미널에 글자 하나만 띄워도.. 희열을 느끼는 부류.
> 모든 원리를 파악할 수 있다면 만족하는 부류

### 원문
---
# 5.0 임베디드 소프트웨어 개발 C++
[[5.1 C++ 입문]]
[[5.2 참조자]]
[[5.3 클래스]]
[[5.4 객체지향 프로그래밍]]

## Orientation

### 임베디드 SW개발 
- 임베디드: 본인의 실력에 좌우되는 밥줄
	- 최적화가 필요하다 -> 하드웨어를 어느정도 알아야 가능하다.
	- Firmware: os없이 직접 하드웨어를 컨트롤 한다.
	- C가 가장 중요하다.
- GUI가 필요한 경우 객체지향 언어를 사용한다. 
	- 사용자에게 UI를 제공하기 위해서
	- 주로C++를 사용한다.
	- `C#`언어를 사용하는 경우도 많다.
### C VS C++
- C언어
	- 구조적 프로그래밍 
	- 시간에 흐름에 따라 동작한다.
	- 구조체
	- 변수 선언 위치가 고정되어있다.
- C++
	- 객체지향 프로그래밍
	- 현실 세계가 복잡해지면서 정보의 양이 많아졌다.
	- 구조체에 대응되는 클래스
		- 함수 추가 -> 전역함수만 있었던 C와는 달리 클래스의 멤버함수
		- 함수 오버로딩, 오버라이딩
		- 생성자와 소멸자 
		- 상속
	- 변수 선언 위치가 자유롭다.
	- new와 delete
	- 참조변수(`&`): 변수의 별칭
		- C에서의 call by reference가 call by value로 전환했다.
- 작은 프로그램인 경우 C로 작성하는 것이 적합하다.
- 중대형 프로그램인 경우 관리를 위해 객체 지향 언어를 사용해야 한다.
### 객체지향 프로그래밍
- 진실로 객체 지향적으로 사고하고 프로그래밍을 할 수 있는가?
- 객체
	- 현실 세계에서 모델링 하려고 하는 구성 요소
- [[프로그램을 왜 짜는가]]?
	- 팔기 위해, 클라이언트를 만족시키기 위해서.
- 객체를 정의 하고, 객체의 관계를 정의하는 방식
	- 맥락에 따라 같은 객체에 대한 모델링 방식이 다르다.
- 언어에 대한 책을 정독하는 것보다 코드를 직접 짤 수 있어야 한다.
- 클래스의 1차적인 목표
	- 캡슐화 -> 하나의 객체에 대한 정보를 하나의 변수에 담는 것.
- 참고
	- [[1.2 좋은 객체 지향 프로그래밍이란|좋은 객체 지향 프로그래밍]]
	- [[객체 지향의 사실과 오해]]
	- [[1.3 좋은 객체 지향 설계의 5가지 원칙 (SOLID)|SOLID 원칙]]
### 프로그램
- 관련있는 명령어의 집합
- c/c++: 컴파일 -> 실행 가능한 파일(`.exe`) -> 실행 -> [[C runtime Environment|Startup Code]](초기화 코드) -> 
	- 리눅스 `.elf`
	- 소스코드를 읽고 할당하여 관련있는 영역(RAM)에 얹어준다.
	- 분할 컴파일 시, 각각 파일은 컴파일 되어 각각의 .data, .bss 등을 만들고 링킹 단계에서 같은 영역끼리 합쳐준다.
![[Excalidraw/LIG Nex1_embedded_C.md#^group=oRmn9npNZ7PGki9IV-ltB]]
- [[int의 크기, word의 크기]] [[TODO]]
```c++
int a;
int &b = a;
```
![[Excalidraw/LIG Nex1_embedded_C.md#^group=s16LM00uYYQCpND9nhS8y]]

---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
