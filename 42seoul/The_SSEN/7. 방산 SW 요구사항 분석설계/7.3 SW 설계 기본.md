---
날짜: 2025-02-13
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 심준용(미사일시스템통제기술연구소)
aliases:
---
### 날짜:  2025-02-13 09:08

### 태그: #프로그래밍/임베디드

- [ ] 정독 🆔 취업
>[!메모]
> 시뮬레이터 -> 학사
> 레이더, 탐색기 -> 석사
> 서류 -> sorting -> 기준대로 
> 기준: 학교 네임밸류, 어학성적, 성적이 월등히 좋거나, 입상 경력
> 	1주일 정도 
> 면접: 학교, 성적, 어학 성적 -> 자소서
> 	누구는 안 읽는다. 누구는 읽는다.
> 	성적: 성실도, 전공성적: 전공 지식을 가르치는 데 시간을 다쓴다.
> 	학교만 보는 사람도 있음.
> 	추천하는 방법: 학교가 불만이다... 대학원을 가라.
> 	당근에 면접 스터디나, 취업 컨설팅을 받는 것도 좋다.
> 	챗GPT로 쓰면 다 안다.
> 		- 구조가 똑같다.
> 	인사팀: 학교, 성적 - > 실무진이 그걸 넘겨 받고 검토
> 	spec을 잘 쌓아놓자..
> 	TCP/UDP -> 약어를 아는가? -> transmition connection, user datagram -> OSI 어디 계층에 속하는가?
> 	C/C++ 의 차이 -> 패러다임 차이 
> 	임베디드의 기본은 다 공부를 하라 -> 1레벨 -> 2레벨 -> 3레벨...
> 	통신: OSI7 layer / TCP/IP(5 layer) -> 산업 표준인가? 무슨 표준인가?
> 	구조 잡는 것이 중요하다.
> 		손코딩을 시키고 -> 브릿지 패턴을 적용해라.
> 		코딩하는 사람보다 설계하는 사람이 돈을 많이 번다.
> 
> 	
	architect: 
	business에 따라 language가 선택하는 다르다.
	문법적인 차이를 알아야 한다.

- [ ] 이력서 수정 사항: 교육에서 느낀점 정도만 나올 것 같다. 🆔 취업
	- 협업이 중요하다.
	- 이런 문제가 있었는데, 내가 다 했다! 보다 같이 해결해 나가는 과정이 중요
	- 거짓말쟁이는 안 뽑는다.
	- PT-> 그림을 많이 넣어라. 설명을 기깔나게 하라.
	- 발표 시 우주최강 서정윤 입니다 때려박고 시작
	- **스킬셋 상세하게 -> 프레젠테이션**
		- 내가 유도한대로 질문이 들어온다.
		- 나머지는 CS
	- 미사일 시스템, 해양, 전자전(전자과) 소프트웨어 하는 애들만 있다.


- 네트워크
	- 소켓의 구성요소: IP/Port
	- C++는 시리얼라이즈가 안된다.
		- 개발자가 해줘야 한다.
- private은 개발자끼리 다르기 때문에 

- 통제 기술
	- 
- 교전 통제
	- 해외 출장 -> 두바이, 사우디, 이란
- [ ] 자소서 강점 🆔 취업
	- 프로젝트 내용을 이야기하는 것은 bad
	- 나는 ~를 좋아해서, 
	- 영어를 잘해서
	- 영어 면접 -> 
	- 최소 1년 텀을 가져라
	- 명확하게 모르면 모른다. 공부는 했는데 다른 강점으로 보완하겠다. 들어가서 어떤 식으로 보완하겠다. 등
	- 데이터 통신, 분리된 망 내에서 TCP/UDP/시리얼통신 어떤 것을 써야 할까요 이런 질문에 대답을 잘 할 수 있어야 한다.
	- 강점에는 징그럽게 잘 써야 한다.
		- 잘 한 걸로 써야 한다.
		- 질문이 무조건 들어간다.
		- 자신 있는 것으로 적고 냄새만 맡은 것도 어떻게 사용해서 잘 쓸 수 있을 것 같습니다.라고 말하기
		- 면접은 사용하는 스킬셋, 포트폴리오에 대한 대답을 잘 준비, 면접관이 무엇을 원하는지 
			- 무기체계는 어떤 것을 중요하게 볼 것인가
				- 요구분석이 변경되었을 떄 10년 20년이 지나도 반영을 할 수 있도록 하기 위해
			- 카카오/네이버
				- 스킬셋을 꾸준히 업그레이드할 수 있는 사람
- 한 번 공부해서 되지 않는다.
	- 읽을 때마다 새로운 것이 나온다.
	- 꾸준히 공부한다.
	- 애매하게 알고 있었다면, 유레카가 올 것이다.
	- builder battern -> builder(aircraft).
### 원문
---
# 7.3 SW 설계 기본
- 소프트웨어의 구분 
	- tech
		- 툴, DBMS, 라이브러리 어쩌고
	- business
		- 은행, 미사일 등

### 설계에서 가장 중요한 것은 무엇인가?
- 변화를 수용할 수 있는 설계
- [[GoF의 design pattern]]
	- ㄱ자형 설계
	- 설계 바이블
	- 4명이 모여서 디자인 패턴 조지자.
	- 23개의 디자인 패턴 모두 이렇게 생겼다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=a9gQtTucD8KcAjvIzPfto]]
- 3 amigo
	- UML 만들었다.
- 서론을 넘어가지 말아라
	- 역사를 알아야 한다.
	- The C++를 쓴 사람
		- 시뮬라 언어를 토대로 만들었다. 
		- small talk: 객체지향 언어
	- 조건문 반복문 제어문
		- 프로시저로 감쌌냐
		- 펑션이냐
		- 객체냐
	- C#은 JAVA를 대응하기 위한 언어
	- JAVA 이름
		- 원래 이름 OAK -> 언어의 이름을 정하자. 밖에 오크나무 -> 이미 있다. -> 커피이름으로 하자.
- 취향은 non function
	- Quality attribute
		- 사용자 편의성, 보안성,,, [[ISO 25010]]
	- 미사일 발사 방식
		- 핫론칭: 추진체로 불을 뿜으며 발사
		- 콜드론칭: 가스를 통해, 퐁
		- 요구사항은 non funtional하다.
			- 발사하게 해주세요 X
			- 몇 초 안에 발사해야 해요 O
- UI/UX
	- UI: 기능적
	- UX: 비기능적
- 소프트웨어 디자인
	- 기능성 / 비기능성(Quality attribute) + 제약사항: 비용 일정 사람 언어 프레임워크
	- Qualiy attribute는 고객도 잘 모른다.
		- 인터뷰를 통해 구체화 해야한다.
	- 제약사항은 준수해야 하는 것.
	- 아키텍트는 고객뿐만 아니라 개발자들에게도 반영을 해야 한다.
- 카프카
	- 기술로 접근하지 마라.
	- 누가 왜 만들었는지로 접근하라.
	- publish - subscribe 
	- 링크드인 -> 메시지 주고 받는 것은 기능
	- [[scaleability]]: 규모 변경성
		- scale up/down
		- 카프카를 쓴다? scaleability
	- 확장성
- 요구분석
	- 앞에서 잘 분석해도 다 바뀐다.
	- 주문형 소프트웨어는 숙명
	- 운용이 될 때도 바뀌는 것 -> 외부
- 설계가 중요하다고 생각하신다.
	- 설계가 잘 되어있어야 한다.
- 구현 -> 시험 -> 유지보수
### 객체지향
- 사라질 수가 없다.
- 인간 세계를 반영하고 있다.
	- 강사화 
- SOLID 패턴을 잘 공부하는 것이 좋다.
	- 이 원칙을 잘 지키려고 해야 한다.
- 디자인 패턴을 공부하는 이유 
	- 의사소통의 경제성
		- 옵저버 패턴
			- 데이터를 생산하는 애가 있고 다수의 데이터 요청자, 
			- API: notify, update, attach(register), detach(unregister)
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=7eGcKodYnUb6tChmT2DIq]]
- 프레임워크 vs 컴포넌트
	- 소프트웨어 아키텍쳐 품질 요구사항
	- 아키텍쳐적 요소를 가진것들이 프레임워크
		- 가용성을 제공
		- scailability라는 아키텍쳐적 요소를 
- 라이브러리와 컴포넌트
	- grand ? 그래인드
		- [ ] 컴포넌트 파인그래인드 어쩌고
	- 입자가 작으면 라이브러리, 크면 컴포넌트
- **클래스와 오브젝트**
	- 클래스: 레벨, 비즈니스
	- 교육생 student = new 교육생(서정윤)
	- 클래스는 재사용 불가능하다.
		- 전략은 재사용이 불가능하다.
	- 오브젝트는 재사용 가능
		- 서정윤은 다른 교육으로 튈 수도 있음.
		- 어떻게 추상화하느냐에 따라서 오브젝트는 재활용이 가능하다.
- 일반화 -> 잘못된 객체지향
	- 전략은 비즈니스에서 만든다.
	- OCP
		- 오브젝트를 ~에 쓸 것이다.
		- 전략과 관련
	- LSP
		- 대체가 되더라도 기능이 똑같이 동작해야 한다.
		- 오브젝트(구현체)와 관련

### 객체지향프로그래밍을 배우기 전에
- 객체지향의 5가지 개념
	- 도구
	- 객체 / 클래스 / 캡슐화 / 상속 / 다형성
- 객체지향의 설계 5원칙
	- 도구 설명서
	- [[1.3 좋은 객체 지향 설계의 5가지 원칙 (SOLID)|SOLID]]
- 객체지향 디자인 패턴
	- 도구의 활용용
	- 생성 / 구조 / 행위
## 소프트웨어 개발 개요
### 소프트웨어 개발 프로세스와 방법론
#### 개발 프로세스
- 폭포수 모델
	- 분석, 설계, 구현 및 시험 등을 순서대로 해나가는 모델
	- 엄무 중심의 프로젝트 조직성 용이
	- 요구분석
		- 설계할 때도 생기고, 구현할 때도 생긴다.
	- 아주 규격화된, 정형화된 개발에만 사용할 수 있다.
- V모델
	- 넥스원 -> 요구분석부터 유지보수까지 다 한다.
	- LG 아키텍트 교육과정을 보면 넥스원이 짱이다.
		- 요구분석을 하는 방법을 모른다.
	- 연차가 쌓이면 모르는 게 없다.
		- 시스템이 복잡해지면서 시스템 전체를 볼 줄 아는 사람이 필요하다.
	- [ ] 넥스원의 장점 🆔 취업
- 프로토타이핑
	- 일반 IT회사의 개발 프로세스
		- 프로토타입, 만들고 머린다.
- 나선형 모델
	- 프로토타이핑과 비슷
	- 4가지 단계를 반복 순환
- 진화적 모델
	- 핵심 부분을 계속 개선하여 시스템을 고도화하는 ㅓㅅ
- 애자일 모델
	- LG전자에서 많이 사용한다.
	- 프로젝트에 대한 피드백을 빨리 받아 방향 평가 짧은 주기
	- 익스트립 프로그래밍, 스크럼 등
#### 개발 방법론
- 구조적 개발 방법론
- 정보공학
- 객체지향
- 컴포넌트
	- 재사용성이 높아진다.
	- 'ㄱ' 설계
### 소프트웨어 요구 분석
- 프로세스가 결정이 되면
#### 요구
- 시스템이 **무엇**을 하고, 어떤 특징을 갖는지를 명확히 정의한 것
- 함수형 프로그래밍은 **"무엇"을 중심**으로
	- 고차함수(High order function)
		- 함수를 arg로, return해서 받을 수 있는 것
	- 자바(1.8)는 stream이 있다.
		- 큰 데이터에서 정보를 빨리 추출할 수 있는 방법들을 정의한다.
		- 교환법칙, 결합법칙이 가능하다.
			- rage evaluation이 가능하다.
			- 무한대로 판별.2의배수구하라.3의배수구하라(아직도 무한대).100이하구하라
	- 함수형 프로그래밍이 왜 부상했을까?
		- 대용량 데이터를 줄여가고 있다.
		- 빅데이터를 정제해야 한다.
		- **정제해서 원하는 데이터를 뽑아오는 것**
		- C#은 Linq가 있다.
			- 선언형 언어(SQL)를 표방
- 1급 객체
	- 함수가 되고, 객체가 되고, 프로시저가 될 수 있다.
	- 대부분 하이브리드 언어라고 할 수 있다.
- C언어는 함수가 아니다.
	- 프로시저이다.
- 프로시저와 함수의 차이
	- 함수는 무엇을 하는가를 정의한다.
	- 프로시저로도 함수를 구현할 수 있다.
	- C언어로도 객체지향 프로그래밍이 가능하다.
		- 프로시저와 스트럭트를 잘 붙여서 만들 수 있다.
		- 할당받아 식별받을 수 있도록 한다.
		- [[객체지향 언어가 아닌 언어로 객체지향 프로그래밍을 하는 법]]
- 아규먼트와 파라미터
	- function(a, b) 호출시 아규먼트
	- function(int a, int b) 정의시 파라미터
- 객체 지향프로그래밍이란
	- **객체와 객체 간의 메시지를 주고받는 프로그래밍**
	- 메시지란?
		- 상대방의 public 메서드 들에 값의 집합을 넣는 것.
		- 메시지를 호출한다.
		- 메시지를 보낸다. -> 아규먼트
- **객체의 구성요소**
	- 행위(기능): 동사
	- 속성(attribute)
	- 식별
#### 요구 분석
- 사용자의 요구에 대해 이해하는 단계
#### 요구 분석 작업
- 요구 추출
- 요구 분석 및 정의
- 요구 확인
	- 인터뷰, 컨퍼런스
	- 이걸 못하기 때문에 승진이 막힘
#### 요구의 분류
- 기능
	- Use Case
- 비기능
	- **품질**이 중요
		- 시나리오로 정의된다.
	- 제약사항
#### 기능 요구
#### 기능 요구의 표현
- 요구사항 분석서에 들어간다.
	- 없다면 끌어내야 한다.
#### 비기능 요구의 표현
- 교전 할당은 3초 이내 ~
	- 추상화 하면 안 된다.
#### 요구 대상에 의한 분류
---> 주니어에서 시니어로 넘어갈 때 필요하다.
- 분류가 잘 되어 있어야 각 부분을 대체하여 나아갈 수 있다.
#### 요구 추출 방법
- 어떤 요구가 있는지 찾아내는 방법
	- 고객 프레젠테이션 시키거나, 인터뷰,  찾아내서 브레인 스토밍 -> 문서화
#### 요구분석 및 정의
- 요구 분석을 통해 설계 기능을 배치할 수 있다.
	- 구현은 색칠만 칠하면 된다.
#### 요구 검증
- 명세서 SRC software requirement spcification
	- 이런 것이 없는 회사는 위험하다.
	- 잘 정의가 되어있어야 비즈니스 모델이 잘 돌아간다.
- 품질 팀
	- 요구 분석이 잘 되어있는가?를 본다.

### 소프트웨어 요구 모델링 및 설계
#### 요구 모델링과 분석의 차이점
- 요구 모델링은 고객과 개발자가 무엇이 개발되고 있는지에 동의하는 것
- 요구 분석의 주요 목표는 구충 중인 시스템에 대한 설명을 제공하는 것
#### 요구 모델링
- 품목, 고객, 개발자
- 모델링은 추상화 작업이다.
	- 인터넷 통신이 되는 기기를 만들고 싶다.
	- 고객과 개발자가 이런 품목을 만들자!라고 동의하는 것
- 요구 분석
	- POC를 통해 요구사항을 구체화 해야 한다.
	- 고객도 무엇을 만들어야 하는지 모른다.
- [ ] UML 꼭 알아야 하나요? -> 규모가 크면 OK, 아니면 안 할 수도..
	- Unified Modeling Language
- 마틴 파울러
	- 리팩토링 기법을 이야기한.
- TCP/UDP
	- 신뢰성 차이: 데이터가 유실될 수 있다.
	- 라우터에서 소실
		- 3layer
		- 라우터의 메모리 버퍼가 다 차면 뻗는다.
		- 오면 버린다. -> 살기 위해서
	- 왜 비연결이냐.
		- **세션**이 없다.
		- TCP에서는 packet -> stream
		- UDP 에서는 datagram -> message
	- **라우터가 없으면, TCP/UDP나 똑같다.**
		- TCP는 다 받아서 느리다.
			- 세션 유지
		- UDP는 다 버려서 빠르다.
	- 브로드캐스팅/멀티캐스팅
		- UDP
	- 유니캐스팅
		- TCP
- realiable UDP
	- 애플리케이션에서 부족한 데이터를 다시 요청
#### UML 기반 모델링 과정
- 요구를 Use case 다이어그램이라고 한다.
- 클래스 후보를 찾아내고 개념적인 도메인 모델 작성
- Use Case 기초하여 시퀀스 다이어그램
- 클래스의 속성, 기능, 클래스 사이 관계를 찾아 도메인 모델 완성
- 필요에 따라 상태 다이어그램 및 활동 다이어그램 추가
- 서브 시스템 파악 -> 전체 시스템 구조 설계
- 적당한 객체를 찾아 설계

- Use Case description
	- pre, post 조건
	- 시나리오에 대한 설명을 잘 해놓아야 한다.
- 그림하나 설계하나
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=bIiBYHqgezIWxpuq127Z6]]
- 미사일 하나 만들어 주세요. 이런 말은 없다.
	- 클래스: 장거리 지대공 유도무기 
	- 객체: 특정한 미사일

- 발표 때문에, 대화를 위해 다이어그램을 그리는 것이다.
	- **꼭 있어야 한다.**
	- [ ] 프로젝트마다 다이어그램 그리기

- 클래스는 코드, 문서다.
	- 객체는 코드나 문서가 아니다.
	- 인스턴스
- 디자인에서는 클래스가 없어도 된다.
#### UML 모델링은 어떻게 할 것인가?
- 모델링 전문가가 필요하다.
- 고객과 개발자가 공동 작업
- **경험이 중요하다.**
	- 조직의 환경이 반영되어있다.
#### 요구분석과 설계
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=ASbKtPJEMkadLD_NB3iQp]]
- **요구분석 : 무엇을 개발할 것인가**
	- 출근한다.
	- 유스케이스
- **설계: 어떻게 실현할 것인가**
	- 집에서 나와서 버스타고 지하철 타고 온다.
	- 시퀀스, 행동 다이어그램
		- 시나리오를 그릴 수 있는 것
- 왜 이렇게 타이트하게 있을까?
	- 랩소디, 래셔널 회사 스트릭트하게 한다.
	- 코드로 만들어준다.
	- 15년에 Model Driven 설계를 하다가 무너졌다.

> [!아키텍쳐 설계 ]
> -> 개발 시스템은 무엇이 중요한가?
> 개발 덕후가 되면 안 된다.. 설계자가 되어야 대우를 받을 것이다.

- 설계를 가지고 기능구현 하지말고, 아키텍처 스타일이 필요하다.
	- 건축에서 왔다.
- 아키텍처 설계의 중요성
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=gIsfrNbZSedYh2cylAl0Q]]
#### 전통적인 설계 원리
- 추상화
	- 대상에 대해 특정한 목적에 관련된 정보에 노출
- 캡슐화
	- 관련된 서비스를 만들고 interface만 노출
- 모듈화
	- 코드의 덩어리
#### 객체지향 설계 원리
- [[1.3 좋은 객체 지향 설계의 5가지 원칙 (SOLID)|SOLID]]
```
소프트웨어 디자인 패턴
ㄴ SOLID 원칙
	ㄴObject Oriented Design
```
- SRP: 단일 책임 원칙
- OCP: 개방-폐쇄 원칙
- LSP: 리스코프 치환 원칙
- ISP: 인터페이스 분리 원칙
- DIP: 의존관계 역전 원칙
#### 소프트웨어 설계 과정
- 아키텍쳐적 요인
	- 설계 목적
	- 품질 속성
	- 최우선 기능
	- 아키텍쳐 관심사.
		- 품질 속성, 제약사항
	- 제약 사항
- 설계 결정
	- 아키텍쳐 요인을 가지고 문서화
- 문서화된 설계 결정 결과 구조
	- 글은 오해가 없다.
	- 그림은 오해의 소지가 있다.
	- 문서화가 중요하다.
### 소프트웨어 코딩 및 테스트
#### 코딩
- 프로그래밍
- 모듈에 대한 원시 코드를 작성하며 문서화하는 것
#### 코딩의 목표
- 설계한 기능을 프로그램으로 구현하는 일
- 가독성을 높이고 유지보수를 편하게 하는 작업
- 리팩토링
	- 잘하는 사람이 해야 한다.
	- 의존
	- 디자인 패턴 적용 등
- 클린코드: 의존성을 잘 관리하는 것
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=HeQMg2wd]]
- 객체끼리 주고받는 메서드는 변경이 일어나면 안 된다.
	- public 메서드가 수정되는 일이 있으면 안 된다.
	- 설계 시점에 모두 반영이 되어있어야 한다.
#### 프로그래밍 언어와의 관계
- 정확하고 간결한 코딩을 한느 것은 프로그래밍 언어의 선택과 무관
	- 상대적으로 현대화 된 언어가 유리
#### 코딩 스타일
- 간결하고 읽기 쉬워야 한다.
	- [[Code Complete]]: 좋은 코드, 좋은 함수를 만드는 것.
	- 변수 이름: 누구나 알 수 있는 이름 -> 비즈니스 도메인 -> ubiquoatous language로 지어야 한다.
		- [[DDD]]에 준하는
#### 가독성 좋은 코드
- 고유한 기능은 독립적인 모듈
- 모듈의 기능을 쉽게 파악할 수 있는 코드
- 불필요한 코드가 없다.
	- 쓰지않는 주석 코드
	- 쓰지 않는 변수, 함수 등
- 잘 정돈되고, 합리적인 Convention을 따른다.
	- [ ] [[리팩토링]], [[디자인패턴]] 도서를 성경처럼 갖고 다녀야 한다.
#### 설계 vs 구현
- 90% 이상 설계
	- 100% 과실은 없다.
	- 문제가 생긴다. -> 설계의 과실이 크다.
- [ ] 설계서를 보고 구현 언어로 작성하는 것은 문제가 되지 않는다. 라고 해야 한다. 🆔 취업
#### 테스트
- 소프트웨어 개발 과정에서 발생한 결함을 발견하는 것
#### 테스트의 접근 방식
- 블랙박스 테스트
	- 기능 테스트
- 화이트박스 테스트
	- 구현 방식 테스트
#### 테스트를 위한 가장 바람직한 방법
- 입출력 값 범위에서 가능한 모든 값을 주고 테스트하는 것
	- 버그를 찾는 것은 아니다.
- 테스트 케이스 선택이 중요하다.
- Given When Then
	- Given: 준비, your condition 
	- When: 실행, What you do
	- Then: 검증, What you see
- ABC 가 노말, ABD로 가는 경우
- [[xUnit pattern]]
	- jUnit
	- CppUnit
	- xUnit 패턴을 구현한 테스트 프레임워크 
	- fixture: 고정체
		- 테스트 케이스 - 테스트 스위트 - fixture...
- 개발자라면 모두 알아야 한다.
#### 검증과 확인
- 검증: 요구 명세의 기능/비기능 요구사항에 대한 준수
- 확인: 사용자 기대에 대한 충족
#### 테스트 단계
- 단위
	- 각 모듈 시험
	- 모듈 정확한 구현 점검
	- 구현
- 통합
	- 전체 모듈 통합하여 시험
	- 시스템 요구 기능 수행 점검
- 시스템
	- 완성된 제품 점검
	- 설계
- 인수
	- 사용자가 직접 사용함으로써 이루어지는 테스트
	- 요구사항
#### 신뢰성 시험
[[7.1 무기체계 SW 테스팅 및 SW 신뢰성 시험]]
- 정적 시험
	- 코딩 규칙
	- 취약점
	- 코드 메트릭
- 동적 시험
	- 문장
	- 분기
	- MC/DC
#### 신뢰성 시험 도구
- QAF, Sparrow, LDRA, Visual Studio Code analysis
#### 코드 메트릭 점검
#### 유지보수
- 결함을 고치거나, 성능을 높이거나, 새로운 기능을 추가하거나, 변경된 환경에 적용
- 기능 개선, 배포할 때 필요
#### 유지보수의 종류
- 수정형
- 적응형
- 완전형
- 예방형
- 실제 stake holder끼리 -공통언어를 위한...
### 소프트웨어 유지보수 및 품질
#### ISO/IEC 9126 Software quality model
- 능력
	- 기능보다는 품질
#### software architecture in practice
- [ ] 언젠간 읽어야 한다.[품질속성 바이블](https://www.google.com/search?q=software+architecture+in+practice&sca_esv=4be518e6148afb1c&ei=HpmtZ7bHF5-4vr0PsbLHgQU&ved=0ahUKEwi2zp-tisCLAxUfnK8BHTHZMVAQ4dUDCBA&uact=5&oq=software+architecture+in+practice&gs_lp=Egxnd3Mtd2l6LXNlcnAiIXNvZnR3YXJlIGFyY2hpdGVjdHVyZSBpbiBwcmFjdGljZTIFEAAYgAQyBRAAGIAEMgUQABiABDIFEAAYgAQyBRAAGIAEMgQQABgeMgQQABgeMgQQABgeMgQQABgeMgYQABgKGB5I_RJQnwxYlhJwAHgCkAEAmAHNAaAB-wWqAQUwLjMuMbgBA8gBAPgBAZgCBaACjwbCAgQQABhHmAMA4gMFEgExIECIBgGQBgqSBwUxLjMuMaAHqCA&sclient=gws-wiz-serp#vhid=4ZWT2kOC3iXu6M&vssid=_I5mtZ7_iL__m1e8Ph_-byAQ_50)
#### 우리에게 필요한 것
- 어떻게 품질 속성을 
- 품질 속성 시나리오를
#### 품질 속성 시나리오
- 공통 양식
https://wide-shallow.tistory.com/112

#### 시스템의 트랜잭션 처리 시나리오
[[7.2 지능형시스템을 위한 SW개발방법론]]

#### 기능 요구사항과 품질속성 요구사항
- 정의
	- 기능: 시스템의 수행하는 행위
	- 품질속성: 시스템이 이해관계자의 요구를 얼마나 잘 만족시키는지
- 품질 속성간 트레이드 오프가 있다.
	- 성능이냐, 효율이냐 
- 품질속성
	- 아키텍처에 큰 영향을 미친다.
	- 요구사항 명세: 6 part quality attribute scenario
- UML을 그리는 것은 의사소통을 위한 것이다.
	- 발표를 위한 수단.
- 요구 기능 보다는 품질 속성에 따라 아키텍처를 결정한다.
---
## 객체지향 설계 기본
### 객체지향이란
#### 객체지향을 이해하기 어려운 이유
- 개념 자체가 모호한 용어로 조합으로 설명되기 때문에
	- [[추상화와 일반화]]
		- 클라이언트가 정해서 결정
		- 공통 속성을 모아 일반화
		- 결과물은 똑같다.
		- 탑다운과 바텀업
		- 일반화는 사라져야 하는 말이다.
- 객체지향 개념을 이해하지 못하면 객체지향 설계가 아닌 **개발에만 익숙**해진다.
- 객체지향이 무엇일까요?
	- 명확하게 이야기할 수 없을 때는 특징을 이야기하는 것이 좋다.
	- ~\~\~한 것들을 객체지향이라고 합니다.
	- C++ main에 갈겨써도 프로그래밍이 가능
#### 객체지향 프로그램은 어떤 목적을 이루기 위해 협업하도록 구성되어지는 객체들의 집합
- 협업을 위해 메시지를 교환
#### 코드 재사용 증가, 유지보수 비용을 감소시키는 장점을 얻기위해 객체를 연결시켜 프로그래밍
- 객체지향 언어 활용
- 객체지향 설계 패턴 활용

-> Interface, 오브젝트가 해야 하는 것들을 정하는 것이 가장 중요하다.
	-> x(), y()가 필요하다? ISP -> 새로운 인터페이스로 분리하라.
	-> SRP 원칙이 깨진다.
	- 필요하다면 책임을 여러 개 가져도 된다. -> 비즈니스가 최우선.
- DIP는 프레임워크를 개발할 수 있는 개발자가 되어야 한다.
	- C++에서는 callback으로 DIP를 넣어준다.
- 비즈니스의 기능적/비기능적 요소
	- 카프카 -> scailability
	- 프레임워크의 결정은 신중해야 한다.
		- 아키텍쳐가 결정이 된다.
		- 편의점 가는데 트럭을 뽑은 격
#### 객체지향을 지원하는 언어의 특징이 있는가?
- 언어 또는 기술이 다음을 직접 지원한다면 객체지향
	- 추상화
- C++ 창시자: 비야네 스트롭스트롭
- 다형성
	- 컴파일 타임에 결정되는 것
	- auto
#### 객체지향을 이해하기 전
- 객체지향 프로그래밍 관점
	- 진화적
- 객체지향 패러다임 관점
	- 절차적 프로그래밍과는 전혀 다른 혁명적
#### 객체지향 프로그래밍 이해를 위한 5가지 개념
- 객체
	- **상태**: 데이터
	- **행위**: 행위의 집합
	- **식별**: 객체를 구분할 수 있는 식별
		- 주소도 무섭다.
		- 식별자를 만든다.
		- 클래스에 ID를 설정한다.
	- 자바와 C++ 메서드와 멤버 함수의 차이
		- 멤버 함수: C++는 C를 표방했기 때문에 (시뮬라와 스몰톡이)..
		- C도 나쁘다. 함수가 아니라 프로시저
- 클래스
- 캡슐화
- 상속
- 다형성
#### 객체지향 프로그램을 사용하는 것
- 클래스 지향이 아닌 객체지향
	- inheritance vs Association
- 클래스 다이어그램을 그리려고 한다?
	- 멈춰.
	- 시퀀스 다이어그램, 액티비티 다이어그램 -> context를 보고 클래스를 도출한다.
#### 객체지향 프로그램을 작성하기 위한 중요한 작업
- 적당한 객체를 찾는 것.
- 객체의 크기, 종속성, 유연성, 성능, 진화 가능성, 재사용, Etc.
- 겍체 지향 설계를 한다는 것 
	- 시스템을 할 적당한 객체로 분할하는 일
	- '무엇'을 정의한 객체 간 의사소통(Collaboration)이 중요.
		- Asynchronous 발음 같은 것들..
		- Asymetric
- 소프트웨어
	- devide and conqour
- 객체를 찾아야 메시지를 찾을 수 있다.
	- 상대방의 public 메서드가 뭐가 있는지  
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=I7cOL43r-_qKNGWSi_SjY]]
#### 적당한 객체를 찾는 것.
- 객체의 책임을 결정하는 것이 설계의 출발점
- 클래스 다이어그램은 설계가 아니다. 
	- 시퀀스 다이어그램이 설계다.
#### 객체의 상태(State)
- 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다.
- 객체에 존재하는 정적, 동적 속성으로 구분한다.
	- 단순 값과 객체를 참조하는 링크로 구분
- 객체의 3요소를 알면 class 키워드가 없는 언어에서도 객체지향 프로그래밍이 가능하다.

#### 객체의 행위(Behavior)
- 외부의 요청 또는 수신된 메시지에 응답하는 활동
- 상태를 변경하거나 다른 객체에게 메시지를 전달해야 한다.
- 행위를 통해 다른 객체와 협력하므로 외부에 가시적이어야 한다.

#### 객체의 식별(Identity)
- 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 속성
	- 상태와 행위가 캡슐화 되어있는 것은 식별이 가능해야 한다.
- 객체는 상태가 변경될 수 있기 때문에, 동일한 속성과 값을 가져도 서로 다른 객체로 식별이 가능하다.
- 객체지향 프로그래밍이란.
	- 객체와 객체를 메시지로 상호작용
#### 클래스란 무엇인가
- 객체의 상태를 저장하는 데 사용될 속성 정의
- 객체가 이해할 수 있는 메시지와 메시지의 응답하는 과정을 정의
- [ ] [[비행기의 heading, roll, pitch]]: 미적분...책을 봐야 한다.
- 객체는 재사용한다.
	- 컴포넌트는 재사용 불가능, 맥락에 따라 코드가 달라지기 때문에
	- 겍체는 문서로 나와야 한다. 
- **객체가 나왔을 때 클래스로 바로 갖도록 하면 안된다.**
	- 하물며, 겉으로 보기에 그것 자체로 보이더라도..
```
Airplane a = new AirPlane();
-> a가 어떤 객체인지 나와있다. 
-> A380, B747, 스펙이 모두 요구사항에 나와있다.
```
- 시뮬레이션 팀에서는 
	- heading, roll, pitch, 위경고도가 필요 추상화가 많이 된다.
	- 날리기만 하면 된다.
- 점검팀
	- 점검은 점검만의 일이 필요하다.
- 클래스가 될 수 있는지 없는지는 스펙으로 보고 들어간다.
	- LSP위반을 주의
- F22가 라이브러리로 제공되어 있는 경우
	- 스펙이 라이브러리로 구현이 되어있는 경우.
		- 안에 있는 메서드를 호출..어쩌고..
	- [ ] [[어댑터패턴]]
	- 어댑터 패턴으로 구현한다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=k7dRpWTwJBWWK8TpYDdr6]]
#### 클래스는 객체 생성의 청사진
- 실제 객체에 대한 코드는 작성할 수 없다.
- 객체를 만드는 사용되는 방법을 작성
#### 객체 == 변수, 클래스 == 타입
- 클래스는 어떤 역할을 하는지, 무엇을 저장할 수 있는지를 기술
- 객체는 실제 값을 저장
- 요구사항 문서에 클래스가 표현되는 것이 없다.
	- **클래스는 객체를 어떤 컨텍스트에서 사용할지에 따라서 달라진다.**
- [ ] 정책을 하나 OCP로 만들고 LSP를 지켜서 구현체를 만들어라.
#### 캡슐화
- 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉하는 것
	- 요청: 객체가 연산을 실행하기 위한 유일한 방법
	- 연산: 객체가 내부 데이터 상태를 변경하는 유일한 방법
- 캡슐화를 통해 정보를 은닉한다는 것은 데이터를 은닉하는 것이 아닌 **구현을 은닉하는 것**이다.
- **문맥을 보고 객체를 파악한 뒤에 추상화를 하라.**
	- 일반화는 위험하다.
		- 초등학생이랑, 취준생이랑 같이 일반화를 해서 넥스원으로 넣으면 아뿔싸.
		- 실제 객체는 기능이 없는데, 소프트웨어에서는 구현에 따라 가능하기 때문에 
- get set -> 캡슐화를 어기고 있는 것이다.
	- 비즈니스에서는 거의 없다.
	- 지금 정상이니, 시동 켜줘, 어쩌고,,,
	- 비행기 어쩌구 권한을 get 해서 시동하는 객체가 있다? -> 병합 대상
#### 캡슐화 규칙
- Tell, don't Principle
	- 로직이 데이터를 요청해서 직접 핸들링 하고있다면 같은 대상이 될 수밖에 없다.
- Law of Demeter
	- 모듈간 결함을 최소화 하라.
	- ㄱ이 예쁘게 안나오면 리팩토링 하세요.
#### 상속
- 코드를 재사용한다보다는 **컨셉을 재사용** 하기 위험이다.
- 부모 클래스가 갖는 모든 데이터와 연산을 서브클래스를 갖는 것
- 상속은 계층 구조를 표현하는 것이다.
	- 어디에 속할 수 있는가 LSP 원칙과 관련
	- 상속은 추상화를 구조화할 수 있다.
	- 단순 분해가 아니라 계층화
- 비즈니스 코드 -> 테크니컬 코드
- 상속 == LSP 원칙에 대한 표현
- 클래스는 추상화, OCP 에 대한 표현
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=6p2__rzMwrIZ_DLGPF7vW]]


- 인터페이스
	- 어떤 클래스에서 더 특화된 클래스를 위한 행동을 제공할 수 있게 한다.
#### 다형성
- OCP와 LSP를 지키면 자연스럽게 
- 한 행동을 여러 방법으로 구현하고 상황에 따라 적당한 구현을 선택할 수 있도록 기능 제공
	- 흐름제어를 단순화한다.
- [[Binding]]
	- 굉장히 중요
	- 소프트웨어 구분할 때, if else if ... switch case case....
	- 바인딩으로 모두 해소가 된다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=RLm8SWxW]]
- [ ] 마틴 파울러의 리팩토링

- 책임: 어느 컨셉에서 쓸 것인가
	- 강사 / 학생

### 객체지향 설계 원칙
#### 설계의 품질
- 잘 설계된 시스렘
	- 이해하기 쉽다.
	- 바꾸기 쉽다.
	- 재사용 쉽다.
	- 단순하고 간결하며 경제적이다.
- 나쁜 설계
	- 무엇이든 하나를 바꿀 때마다 반드시 다른 것도 바꾼다.
	- 한 부분을 변경하면 상관없는 부분이 동작을 멈춘다.
	- 개발 환경에 대한 의존성이 심하다.
	- 복사와 붙여넣기를 통해 코드가 불필요하게 반복된다.
	- 코드를 만든 의도를 알 수 없다.
#### 설계의 품질을 높이기 위해서는 무엇이 필요한가
- [[1.3 좋은 객체 지향 설계의 5가지 원칙 (SOLID)|SOLID]]
- **SOLID**ify your software design
	- stack over flow
		- 질의응답
	- [ ] code project https://www.codeproject.com/
		- 자랑질 하는 곳
- OCP와 LSP가 가장 중요
	- **추상화(Open_객체는 자유로워 Close_기능은 제한)와 상속(클래스 안에서 자유롭게 대체가능해야 한다)**
- DIP는 개념에 대한 문제
- 인터페이스 분리원칙 ISP
	- **! OCP, 원칙을 결정할 비즈니스를 분리해야 한다.** 
	- TCP/UDP와 관련된 클래스를 한다?
- 설계는 언제나 trade off가 존재한다.
	- 다 분리를 해버리면 복잡해진다.
		- 관리할 문서와 코드 단위가 늘어난다.
	- 아키텍트는 이것을 분리할지 말지에 대해서 결정한다.
- 클래스는 책임을 가지고 있다. 컨셉
	- `~~를 할 수 있다.`를 가져온다.
	- JAVA의 thread, runnable -> 
	- 클래스를 상속 받지 마라.
		- 거기에 대한 인터페이스를 상속받아라.
		- 옵저버가 되어라! X 옵저버의 기능을 가져 O
		- 클래스는 Identity가 같아진다.
	- 추상 클래스
		- 추상 클래스 사용도 회의적이다.
#### SRP
- single responsibility principle, 단일 책임 원리
	- 지킬려고 노력만 하라.
	- 안 지켜진다면 이유가 있다. (비즈니스적 요소)
- A class should have only one reason to change.
- 임베디드 소프트웨어의 성능도 좋아지고 있다.
	- 유도무기와 미사일
		- 그냥 미사일 -> 좌표 찍어 발사 -> 크루즈 비행
		- 가이던스 툴 -> 임베디드 시스템 -> 슈퍼 컴퓨터급
		- 다기능 레이더 표적 어쩌고 -> 통제소 -> 미사일한테 알려줌
	- 소프웨어를 타이트하게 짤 필요가 없다.
		- 워크스테이션 급
	- [[ICD]]
		- 메모리를 꾸겨넣는다. 4바이트 float -> 2바이트로 encoding -> 연산이 많아진다.
	- [ ] 고전으로 공부하면 안된다. 데이터 아낀다 구조 심플 X 10년 전부터 달라진다. 🆔 취업
		- 임베디드도 고도화 중
	- 임베디드에 대한 개념 자체를 내장되어있다. 로 바꾸고 -> 상용 소프트웨어 처럼 개발하고 있다.
		- 디자인 패턴을 적용해서 구현하고 있다.
##### SRP를 사용하지 않은 클래스를 찾아내는 방법
- <> 클래스가 자신을 <> 한다.
- 작성 후 해당 내용이 말이 안되면 SRP를 위반하고 있을 확률이 높다.
	 - save / log 같은 메서드
	 - logger와 saver를 분리하라.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=AFu5GUQ3QRbWEWCy9DgOo]]
#### OCP
- 기존 코드를 변경하지 않으면서 코드의 수정을 허용하는 것에 관한 원리
	- 객체의 기능을 구현하는 방법의 구현은 자유롭게
- **사용자는 추상화를 활용한다.**

![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=-eu5vXX0lR7OjB7XfTW81]]
```c

setPathPattern(PathPattern * pp) { // <- 유저 비즈니스에서 넣어준다.
	...
}

void draw()
{
	pathPattern->nextX();
	pathPattern->nextY();
}
```
#### LSP
- 리스코프 바바라
	- MIT 공학 교수
- 하위 타입의 객체는 상위 타입의 객체를 대체할 수 있다.
- 객체 지향 상속은 분류이다.
- LSP는 설계한 클래스의 상속 구조의 문제점을 찾아준다.
- LSP를 위반한다면 혼란스러워진다.
	- 상위 클래스에 모든 기능을 정의
- 너무 복잡?
	- 다른클래스에 위임
- 아키텍트가 되고 싶다면, 트레이드 오프라는 이야기를 하면 반절 먹고 들어간다.
#### ISP
- 자신이 사용하지 않는 인터페이스에 의존 관계를 맺으면 안된다.
- SRP와 마찬가지로 변화에 대응
	- SRP는 클래스 분리
	- ISP는 인터페이스 분리

- 밸브 열기 - 가역 - 비가역 - lift off
	- 10ms 남짓 -> RTOS, VxWorks
#### DIP
- Depend upon Abstractions. Do not depend upon concertions.
- 의존관계 역전 원칙

- 까만 마름모
	- 유도탄과 탐색기
	- 자동차와 바퀴
- 빈 마름모
	- 학교와 학생

![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=9GU9Se6YDWRiHYH8kSU9C]]
**-> DIP는 프레임 워크의 핵심 원칙**
- 아키텍처적 요소
	- 기능과 / 비기능
	- 비기능적 요소에 대한 결정이 들어있다.
	- NoSQL을 써야해 -> 그걸 알고 프로그래밍 한다? 망한다.
		- 비즈니스 코드까지 들어온다? 망했다.
		- 특정 퀄리티 요소를 반영하기 위한 정보들을 
#### 설계원칙 정리
- SRP: 객체간 책임 분배 확실
- OCP: 비즈니스에서 정한 
- LSP: ...
- ISP: 인터페이스를 변화의 장벽으로 
- DIP: ...

## [[객체지향 설계를 위한 UML]]

## 객체지향 설계 방법
## 디자인 패턴 기본

---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
