---
날짜: "2025-02-16"
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 심준용(미사일시스템통제기술연구소)
aliases:
---
### 날짜:  2025-02-16 23:14

### 태그: #프로그래밍/임베디드

>[!메모]
> 

### 원문
---
# 7.3.2 객체지향 설계 기본
## 객체지향이란
### 객체지향을 이해하기 어려운 이유
- 개념 자체가 모호한 용어로 조합으로 설명되기 때문에
	- [[추상화와 일반화]]
		- 클라이언트가 정해서 결정
		- 공통 속성을 모아 일반화
		- 결과물은 똑같다.
		- 탑다운과 바텀업
		- 일반화는 사라져야 하는 말이다.
- 객체지향 개념을 이해하지 못하면 객체지향 설계가 아닌 **개발에만 익숙**해진다.
- 객체지향이 무엇일까요?
	- 명확하게 이야기할 수 없을 때는 특징을 이야기하는 것이 좋다.
	- ~\~\~한 것들을 객체지향이라고 합니다.
	- C++ main에 갈겨써도 프로그래밍이 가능
### 객체지향 프로그램이란
- 어떤 목적을 이루기 위해 협업하도록 구성되어지는 객체들의 집합
- 협업을 위해 메시지를 교환
### 코드 재사용 증가, 유지보수 비용을 감소시키는 장점을 얻기위해 객체를 연결시켜 프로그래밍
- 객체지향 언어 활용
- 객체지향 설계 패턴 활용

-> Interface, 오브젝트가 해야 하는 것들을 정하는 것이 가장 중요하다.
	-> x(), y()가 필요하다? ISP -> 새로운 인터페이스로 분리하라.
	-> SRP 원칙이 깨진다.
	- 필요하다면 책임을 여러 개 가져도 된다. -> 비즈니스가 최우선.
- DIP는 프레임워크를 개발할 수 있는 개발자가 되어야 한다.
	- C++에서는 callback으로 DIP를 넣어준다.
- 비즈니스의 기능적/비기능적 요소
	- 카프카 -> [[scailability]]
	- 프레임워크의 결정은 신중해야 한다.
		- 아키텍쳐가 결정이 된다.
		- 편의점 가는데 트럭을 뽑은 격
### 객체지향을 지원하는 언어의 특징이 있는가?
- 언어 또는 기술이 다음을 직접 지원한다면 객체지향
	- 추상화
- C++ 창시자: 비야네 스트롭스트롭
- 다형성
	- 컴파일 타임에 결정되는 것
	- auto
### 객체지향을 이해하기 전
- 객체지향 프로그래밍 관점
	- 진화적
- 객체지향 패러다임 관점
	- 절차적 프로그래밍과는 전혀 다른 혁명적
### 객체지향 프로그래밍 이해를 위한 5가지 개념
- 객체
	- **상태**: 데이터
	- **행위**: 행위의 집합
	- **식별**: 객체를 구분할 수 있는 식별
		- 주소도 무섭다.
		- 식별자를 만든다.
		- 클래스에 ID를 설정한다.
	- 자바와 C++ 메서드와 멤버 함수의 차이
		- 멤버 함수: C++는 C를 표방했기 때문에 (시뮬라와 스몰톡이)..
		- C도 나쁘다. 함수가 아니라 프로시저
- 클래스
- 캡슐화
- 상속
- 다형성
### 객체지향 프로그램을 사용하는 것
- 클래스 지향이 아닌 객체지향
	- inheritance vs Association
- 클래스 다이어그램을 그리려고 한다?
	- 멈춰.
	- 시퀀스 다이어그램, 액티비티 다이어그램 -> context를 보고 클래스를 도출한다.
### 객체지향 프로그램을 작성하기 위한 중요한 작업
- 적당한 객체를 찾는 것.
- 객체의 크기, 종속성, 유연성, 성능, 진화 가능성, 재사용, Etc.
- 겍체 지향 설계를 한다는 것 
	- 시스템을 할 적당한 객체로 분할하는 일
	- '무엇'을 정의한 객체 간 의사소통(Collaboration)이 중요.
		- Asynchronous 발음 같은 것들..
		- Asymetric
- 소프트웨어
	- devide and conqour
- 객체를 찾아야 메시지를 찾을 수 있다.
	- 상대방의 public 메서드가 뭐가 있는지  
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=I7cOL43r-_qKNGWSi_SjY]]
## 적당한 객체를 찾기
- 객체의 책임을 결정하는 것이 설계의 출발점
- 클래스 다이어그램은 설계가 아니다. 
	- 시퀀스 다이어그램이 설계다.
### 객체의 상태(State)
- 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다.
- 객체에 존재하는 정적, 동적 속성으로 구분한다.
	- 단순 값과 객체를 참조하는 링크로 구분
- 객체의 3요소를 알면 class 키워드가 없는 언어에서도 객체지향 프로그래밍이 가능하다.

### 객체의 행위(Behavior)
- 외부의 요청 또는 수신된 메시지에 응답하는 활동
- 상태를 변경하거나 다른 객체에게 메시지를 전달해야 한다.
- 행위를 통해 다른 객체와 협력하므로 외부에 가시적이어야 한다.

### 객체의 식별(Identity)
- 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 속성
	- 상태와 행위가 캡슐화 되어있는 것은 식별이 가능해야 한다.
- 객체는 상태가 변경될 수 있기 때문에, 동일한 속성과 값을 가져도 서로 다른 객체로 식별이 가능하다.
- 객체지향 프로그래밍이란.
	- 객체와 객체를 메시지로 상호작용
### 클래스란 무엇인가
- 객체의 상태를 저장하는 데 사용될 속성 정의
- 객체가 이해할 수 있는 메시지와 메시지의 응답하는 과정을 정의
- [ ] [[비행기의 heading, roll, pitch]]: 미적분...책을 봐야 한다.
- 객체는 재사용한다.
	- 컴포넌트는 재사용 불가능, 맥락에 따라 코드가 달라지기 때문에
	- 겍체는 문서로 나와야 한다. 
- **객체가 나왔을 때 클래스로 바로 갖도록 하면 안된다.**
	- 하물며, 겉으로 보기에 그것 자체로 보이더라도..
```
Airplane a = new AirPlane();
-> a가 어떤 객체인지 나와있다. 
-> A380, B747, 스펙이 모두 요구사항에 나와있다.
```
- 시뮬레이션 팀에서는 
	- heading, roll, pitch, 위경고도가 필요 추상화가 많이 된다.
	- 날리기만 하면 된다.
- 점검팀
	- 점검은 점검만의 일이 필요하다.
- 클래스가 될 수 있는지 없는지는 스펙으로 보고 들어간다.
	- LSP위반을 주의
- F22가 라이브러리로 제공되어 있는 경우
	- 스펙이 라이브러리로 구현이 되어있는 경우.
		- 안에 있는 메서드를 호출..어쩌고..
	- [ ] [[어댑터패턴]]
	- 어댑터 패턴으로 구현한다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=k7dRpWTwJBWWK8TpYDdr6]]
### 클래스는 객체 생성의 청사진
- 실제 객체에 대한 코드는 작성할 수 없다.
- 객체를 만드는 사용되는 방법을 작성
### 객체 == 변수, 클래스 == 타입
- 클래스는 어떤 역할을 하는지, 무엇을 저장할 수 있는지를 기술
- 객체는 실제 값을 저장
- 요구사항 문서에 클래스가 표현되는 것이 없다.
	- **클래스는 객체를 어떤 컨텍스트에서 사용할지에 따라서 달라진다.**
- [ ] 정책을 하나 OCP로 만들고 LSP를 지켜서 구현체를 만들어라.
### 캡슐화
- 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉하는 것
	- 요청: 객체가 연산을 실행하기 위한 유일한 방법
	- 연산: 객체가 내부 데이터 상태를 변경하는 유일한 방법
- 캡슐화를 통해 정보를 은닉한다는 것은 데이터를 은닉하는 것이 아닌 **구현을 은닉하는 것**이다.
- **문맥을 보고 객체를 파악한 뒤에 추상화를 하라.**
	- 일반화는 위험하다.
		- 초등학생이랑, 취준생이랑 같이 일반화를 해서 넥스원으로 넣으면 아뿔싸.
		- 실제 객체는 기능이 없는데, 소프트웨어에서는 구현에 따라 가능하기 때문에 
- get set -> 캡슐화를 어기고 있는 것이다.
	- 비즈니스에서는 거의 없다.
	- 지금 정상이니, 시동 켜줘, 어쩌고,,,
	- 비행기 어쩌구 권한을 get 해서 시동하는 객체가 있다? -> 병합 대상
### 캡슐화 규칙
- Tell, don't Principle
	- 로직이 데이터를 요청해서 직접 핸들링 하고있다면 같은 대상이 될 수밖에 없다.
- Law of Demeter
	- 모듈간 결함을 최소화 하라.
	- ㄱ이 예쁘게 안나오면 리팩토링 하세요.
### 상속
- 코드를 재사용한다보다는 **컨셉을 재사용** 하기 위험이다.
- 부모 클래스가 갖는 모든 데이터와 연산을 서브클래스를 갖는 것
- 상속은 계층 구조를 표현하는 것이다.
	- 어디에 속할 수 있는가 LSP 원칙과 관련
	- 상속은 추상화를 구조화할 수 있다.
	- 단순 분해가 아니라 계층화
- 비즈니스 코드 -> 테크니컬 코드
- 상속 == LSP 원칙에 대한 표현
- 클래스는 추상화, OCP 에 대한 표현
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=6p2__rzMwrIZ_DLGPF7vW]]


- 인터페이스
	- 어떤 클래스에서 더 특화된 클래스를 위한 행동을 제공할 수 있게 한다.
### 다형성
- OCP와 LSP를 지키면 자연스럽게 
- 한 행동을 여러 방법으로 구현하고 상황에 따라 적당한 구현을 선택할 수 있도록 기능 제공
	- 흐름제어를 단순화한다.
- [[Binding]]
	- 굉장히 중요
	- 소프트웨어 구분할 때, if else if ... switch case case....
	- 바인딩으로 모두 해소가 된다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=RLm8SWxW]]
- [ ] 마틴 파울러의 리팩토링

- 책임: 어느 컨셉에서 쓸 것인가
	- 강사 / 학생

## 객체지향 설계 원칙
### 설계의 품질
- 잘 설계된 시스렘
	- 이해하기 쉽다.
	- 바꾸기 쉽다.
	- 재사용 쉽다.
	- 단순하고 간결하며 경제적이다.
- 나쁜 설계
	- 무엇이든 하나를 바꿀 때마다 반드시 다른 것도 바꾼다.
	- 한 부분을 변경하면 상관없는 부분이 동작을 멈춘다.
	- 개발 환경에 대한 의존성이 심하다.
	- 복사와 붙여넣기를 통해 코드가 불필요하게 반복된다.
	- 코드를 만든 의도를 알 수 없다.
### 설계의 품질을 높이기 위해서는 무엇이 필요한가
- [[1.3 좋은 객체 지향 설계의 5가지 원칙 (SOLID)|SOLID]]
- **SOLID**ify your software design
	- stack over flow
		- 질의응답
	- [ ] code project https://www.codeproject.com/
		- 자랑질 하는 곳
- OCP와 LSP가 가장 중요
	- **추상화(Open_객체는 자유로워 Close_기능은 제한)와 상속(클래스 안에서 자유롭게 대체가능해야 한다)**
- DIP는 개념에 대한 문제
- 인터페이스 분리원칙 ISP
	- **! OCP, 원칙을 결정할 비즈니스를 분리해야 한다.** 
	- TCP/UDP와 관련된 클래스를 한다?
- 설계는 언제나 trade off가 존재한다.
	- 다 분리를 해버리면 복잡해진다.
		- 관리할 문서와 코드 단위가 늘어난다.
	- 아키텍트는 이것을 분리할지 말지에 대해서 결정한다.
- 클래스는 책임을 가지고 있다. 컨셉
	- `~~를 할 수 있다.`를 가져온다.
	- JAVA의 thread, runnable -> 
	- 클래스를 상속 받지 마라.
		- 거기에 대한 인터페이스를 상속받아라.
		- 옵저버가 되어라! X 옵저버의 기능을 가져 O
		- 클래스는 Identity가 같아진다.
	- 추상 클래스
		- 추상 클래스 사용도 회의적이다.
### SRP
- single responsibility principle, 단일 책임 원리
	- 지킬려고 노력만 하라.
	- 안 지켜진다면 이유가 있다. (비즈니스적 요소)
- A class should have only one reason to change.
- 임베디드 소프트웨어의 성능도 좋아지고 있다.
	- 유도무기와 미사일
		- 그냥 미사일 -> 좌표 찍어 발사 -> 크루즈 비행
		- 가이던스 툴 -> 임베디드 시스템 -> 슈퍼 컴퓨터급
		- 다기능 레이더 표적 어쩌고 -> 통제소 -> 미사일한테 알려줌
	- 소프웨어를 타이트하게 짤 필요가 없다.
		- 워크스테이션 급
	- [[ICD]]
		- 메모리를 꾸겨넣는다. 4바이트 float -> 2바이트로 encoding -> 연산이 많아진다.
	- [ ] 고전으로 공부하면 안된다. 데이터 아낀다 구조 심플 X 10년 전부터 달라진다. 🆔 취업
		- 임베디드도 고도화 중
	- 임베디드에 대한 개념 자체를 내장되어있다. 로 바꾸고 -> 상용 소프트웨어 처럼 개발하고 있다.
		- 디자인 패턴을 적용해서 구현하고 있다.
#### SRP를 사용하지 않은 클래스를 찾아내는 방법
- <> 클래스가 자신을 <> 한다.
- 작성 후 해당 내용이 말이 안되면 SRP를 위반하고 있을 확률이 높다.
	 - save / log 같은 메서드
	 - logger와 saver를 분리하라.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=AFu5GUQ3QRbWEWCy9DgOo]]
### OCP
- 기존 코드를 변경하지 않으면서 코드의 수정을 허용하는 것에 관한 원리
	- 객체의 기능을 구현하는 방법의 구현은 자유롭게
- **사용자는 추상화를 활용한다.**

![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=-eu5vXX0lR7OjB7XfTW81]]
```c

setPathPattern(PathPattern * pp) { // <- 유저 비즈니스에서 넣어준다.
	...
}

void draw()
{
	pathPattern->nextX();
	pathPattern->nextY();
}
```
### LSP
- 리스코프 바바라
	- MIT 공학 교수
- 하위 타입의 객체는 상위 타입의 객체를 대체할 수 있다.
- 객체 지향 상속은 분류이다.
- LSP는 설계한 클래스의 상속 구조의 문제점을 찾아준다.
- LSP를 위반한다면 혼란스러워진다.
	- 상위 클래스에 모든 기능을 정의
- 너무 복잡?
	- 다른클래스에 위임
- 아키텍트가 되고 싶다면, 트레이드 오프라는 이야기를 하면 반절 먹고 들어간다.
### ISP
- 자신이 사용하지 않는 인터페이스에 의존 관계를 맺으면 안된다.
- SRP와 마찬가지로 변화에 대응
	- SRP는 클래스 분리
	- ISP는 인터페이스 분리

- 밸브 열기 - 가역 - 비가역 - lift off
	- 10ms 남짓 -> RTOS, VxWorks
### DIP
- Depend upon Abstractions. Do not depend upon concertions.
- 의존관계 역전 원칙

- 까만 마름모
	- 유도탄과 탐색기
	- 자동차와 바퀴
- 빈 마름모
	- 학교와 학생

![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=9GU9Se6YDWRiHYH8kSU9C]]
**-> DIP는 프레임 워크의 핵심 원칙**
- 아키텍처적 요소
	- 기능과 / 비기능
	- 비기능적 요소에 대한 결정이 들어있다.
	- NoSQL을 써야해 -> 그걸 알고 프로그래밍 한다? 망한다.
		- 비즈니스 코드까지 들어온다? 망했다.
		- 특정 퀄리티 요소를 반영하기 위한 정보들을 
### 설계원칙 정리
- SRP: 객체간 책임 분배 확실
- OCP: 비즈니스에서 정한 
- LSP: ...
- ISP: 인터페이스를 변화의 장벽으로 
- DIP: ...

---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
