---
날짜: "2025-02-17"
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 심준용(미사일시스템통제기술연구소)
aliases:
---
### 날짜:  2025-02-17 10:54

### 태그: #프로그래밍/임베디드

>[!메모]
> 

### 원문
---
# 7.4.5 디자인 패턴 기본
## 문제를 해결하는 방법
- 어떤 방법이 최적의 방법인지는 상황에 맞게 판단닿다.
	- 대부분 우리가 겪고 있는 문제는 유일하지 않다.
- 옵저버 패턴
	- '1대 다'
	- cell에 계산식 -> 계산식이 들고 있는 셀의 데이터를 감시
		- notify, update, attach, detach
- 옵저버 예제
	- Subject와 Observer
		- 둘 다 Interface로 하는 것이 좋다.
	- x와 y를 건네주려면 어떻게 해야하지?
		- 객체를 싹 알려준다? 에바임. 노출하면 캡슐화가 깨진다.
		- DTO 매개자를 정한다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=A_s2lw5pOWqc7ethYPSz6]]
- 펍섭과 옵저버의 차이
	- 옵저버: tightly coupled
		- subject들을 다 알고 있어야 한다.
	- 펍섭: loosly coupled
		- 중간에 **브로커**를 두고 subscriber가 모른다. 
			- 미디에이터 패턴 -> API를 정해놓는 것것
		- 네트워크를 통해 분산환경으로 만들 수 있다.
			- 카프카, DDS
	- 옵저버: 1대 다
	- 펍섭: 다대 다

### 디자인 패턴을 살펴보기 전에
- 디자인 패턴 VS Idiom(IMplementation Pattern)
	- 프로그래밍 언어에 내장되면 Idiom
		- 상속 / 추상 함수
- 디자인 패턴 vs 프레임워크
	- 디자인 패턴은 추상적, 그림
	- 프레임워크 -> 코드, 디자인, 아키텍쳐적인 요소
		- 어떤 품질 속성이 있는지 발견해야 한다.
			- 3주만에 개발이 되어야 해 -> 품질: 제약사항
			- 기능 추가를 쉽게 하고 싶어.
### 디자인 패턴
- 발견하는 것.
	- 쓰다보니 반복되는 것을 발견해서
### 디자인 패턴 무엇이 좋은가.
- 디자인의 경제성, 의사소통의 경제성
### 디자인 패턴의 정의
- 패턴은 구성 요소
	- 패턴 이름
		- 설계 어휘를 늘리고, 높은 수준의 추상화된 설계 가능
	- 문제
		- 언제 패턴을 쓰는가.
	- 해법
		- 설계 구성 요소와 그 요소 간의 관계, 책임 및 협력 서술
	- 결과
		- 적용해서 얻은 결과와 장단점
### 디자인 패턴을 고르는 방법
- 경험이 있어야 한다.
	- 패턴이 어떻게 문제를 해결하는지 파악
	- 패턴의 의도를 파악
	- 관련성 등
### 디자인 패턴의 카탈로그
- 생성 패턴
	- 객체를 생성할 때
- 구조 패턴
	- 프로그램의 구조
- 행성 패턴
	- 객체의 행동을 정의하는 법
### 생성 패턴
- 싱글턴
	- 공유하는 것을 없애자는 것이 프로그램의 지향점
		- 하나만 만들어서 공유를 한다.
		- 공유를 하면 문제가 생긴다.
	- C++를 쓰지 말자는 추세, 함수형 언어를 쓰자, 함수형 언어는 공유를 하지 않는다.
		- 참조 투명성, 불변성
		- 집합처럼 만들어서, 1, 2 / 2, 3 / 3, 4 ..... -> 메모리를 너무 많이 잡아먹는다.
	- getInstance()
	- [ ] callonce() 싱글턴, 뮤텍스 문제를 해결해준다.
- 프로토타입
	- clone() -> 객체 생성
- 브릿지 패턴
	- 객체를 추상화 + 인터페이스를 추상화화
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=vLjoWsLifum_fH9MIiJSO]]
### 구조 패턴
- Facade
	- 가운데에 문을 하나 두는 것
	- visual studio의 빌드
		- 여러 기능을 묶어서 하나의 인터페이스를 제공
- Proxy
	- 윈도우의 방화벽
		- UDP는 짤라버린다. -> 방화벽을 낮춰야 한다.
	- 가짜 객체를 하나 둔다.
- 데코레이터
	- 기능 추가
	- 로깅에서 많이 사용한다.
- Composite 패턴
	- 파일과 폴더, 폴더 안에 폴더
	- 결국 원하는 것은 파
	- 시리얼 통신, 네트워크에서도 많이 사용한다.
		- 직렬화를 하는 방식
		- float -> 직렬화, A -> 직렬화
		- 한 번에 하고 싶다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=tRGj3f0X41CyGX06qgUSR]]
- flyweight
	- 워드 같은 페이지: 'ㄱ'은 얼마나 많이 사용할까
	- 본질적인 것과 본질적이지 않은 것: 폰트 타입, 폰트 형태 ,색 등, 
		- 본질적인 건 공유, 본질적이지 않은 건 합쳐
		- 최소 두 개의 객체를 사용한다.
	- 메모리를 아낄 수 있다.
### 행동 패턴
- Chain of Responsibility
	- 프로그래밍 언어에 많이 구현되어 있다.
	- try/catch
	- 어떤 오류인지 잡아내야 한다.
	- 쭉쭉 따라 간다.
- 커맨드 패턴
	- on/off 커맨더 TV에 등록하면 
- 옵저버
- Strategy
- Template Method
	- Strategy의 대항마
- Iterator
	- STL의 반복자
- Mediator
	- 관여하는 객체가 많을 때, 중개자를 하나 둔다.
- 메멘토
	- undo, redo
### 생성 패턴이란
- Instance를 만드는 절차를 추상화하는 패턴
- 방법
	- 클래스 생성 패턴
	- 객체 생성 패턴
- 특징
	- 시스템이 어떤 구체 클래스를 사용하는지에 대한 정보를 캡슐화
	- 클래스의 Instance를 어떻게 만들고 어떻게 연관되는지에 대한 부분을 캡슐화
### 생성 패턴: 팩토리 메서드
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=5AKEcU9dFs4vkDJMU1G60]]
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=xEW69Sh5DTDYDD1kQM5UR]]
- 운송수단은 점선 / 물류는 실선
- 서브 클래스에 대한 훅 메서드
	- craeteTransport
- 의도
	- 팩토리 패턴을 많이 사용한다.
	- 1이면 피카추, 2면 라이추 ... 빌드 범위가 너무 늘어난다. 
		- else if ... else if ...
		- 조건마다 객체를 만들어라.
		- 코드는 타입을 하나만 쓰고(다형성)
### 생성패턴: Prototype
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=bBg5LsCX2wggAo-OXbCUe]]
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=ea61yYDLRnxUJz2FzrpnA]]
- 의도
	- prototype이 되는 Instance를 사용하여 생성할 객체의 종류를 명시하고 이렇게 만든 견본을...
	- 세팅한 것을 복사하자.
### 구조패턴이란

> [!info] 패턴을 잘 학습하려면
>	- 문제 상황
>	- 패턴의 의도
>	- 의도대로 했을 경우에 장단점
>- 아키텍처, 패턴, 스타일
>	- 기능이 아니라 **품질을 만족**시키기 위한 수단.
>	- 기능은 기본적인 것.
>- 이게 왜 나왔는가?에 대한 설명을 할 수 있어야 한다. Rational
>	- (+) 변경 용이성 VS 퍼포먼스 (-)
>	- (+) ..... VS ....... (-)
>-  리팩토링
>	- 반복되는 패턴에 대한 이름을 붙인 것.
> ![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=9MLpq02kEO1Q-LoR6RX9S]]

- 더 큰 구조를 형성하기 위해 클래스와 객체를 합성하는 방법을 추상화
- 방법
	- 구조 클래스 패턴
	- 구조 객체 패턴
- 특징
	- 런타임에 새로운 객체를 생성하기 위해 객체를 합성하는 방법 제공

### 구조패턴: 어댑터
- wrapper
- Devide and conquor
	- 요구사항 나오면 다 짤라라.
	- Native call -> [[JNI]](JAVA Native Interface)
		- 이기종의 언어들을 호출하는 것을 도와준다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=O3QAn05SRRGe_pcedgZFK]]
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=SIf14XH2jvAjPF29k0egs]]
### 구조 패턴: Bridge 패턴
- 방산에는 크게 쓰이지 않는다.
- **double strategy pattern**로 볼 수 있다.
	- 핸들과 바디? 이해하기 어렵다.
### 구조 패턴: Composite pattern
- 이 디자인 패턴에 유레카가 오면...
	- 모든 프로그래밍 언어를 커버하면서 과외를 할 수도 있다.
	- 고는 덕타이핑 언어이다. -> 문법적으로 유연하다.
- 파일과 폴더
	- 실제 통신할 때는 serializer를 사용한다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=LaFtqQQ6nPZjw7IcrYpts]]

- 디자인 패턴은 발명하는 것이 아니라 발견하는 것이다.
- 레전드
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=AWMrhiSdd3Dt3qyrttGmw]]
- singleton
	- double cheked locking
		- if문을 두 개 써서 방지하도록 시도
		- 이것도 아직 위험하다.
		- 더 나은 방법을 찾기위해 시도해야 한다.
- [ ] 새로운 문법이 무조건 좋다.
	- [ ] 스마트 포인터 -> 팩토리패턴
	- 가비지 콜렉터 처럼
- 디자인만 되면 구현하는 것은 1주일도 안 걸린다.
	- 설계를 어필하라..
	- 억지로 끼워넣지 마라.
	- 이런이런 설계를 통해 이런 언어를 써봤습니다.
		- 스레드를 썼다면
			- context switching, mutex
		- 오타가 있는지 절대로 확인하기
### 행동 패턴: 옵저버 패턴
- 교전, 교전 통제, 작전 통제![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=KLBeSiqjQILsPiTqyf6QS]]
### 행동 패턴: 전략 패턴

### 행동 패턴: Template Method pattern
- 비슷한 함수가 여러 개가 나오고 있다.
- 확장성이 없다? 
	- 코드를 템플릿으로 올려서 다형성만 추가하기
- 메서드는 메서드, 그런데 코드 수준으로 재사용하는 것이 있다.
```c
TemplateMethod()
{
	if()
	{
		...
	}
	else if()
	{
		...
	}
}
```
- 도메인을 잘 아는 개발자.
	- init(), run(), export() -> 이 구조대로 호출이 되어야만 모델이 호출이 된다.
	- 구동되는 프로세스(절차)는 국가연이 알고, 구현은 업체가 안다.
```c
templateMethod() 
{
	bool isOk = init();
	if (isOk)
	{
		...
	}
	if (...)
	{
		run();
	}
	export();
}
```
- 절차만 모를뿐 어떻게 구동하는지만 안다.
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=J7cvSONzl5NzpYmh4mkob]]
### 디자인패턴에서 무엇을 기대할 수 있는가?
- 공통적인 설계자들의 **어휘**로 쓰는 패턴
	- 경제적이다.
- 시스템 문서화와 학습 보조 도구로 쓰는 패턴
- 리팩토링을 위한 패턴
	- 코드를 그냥 옮기지 말고 디자인 패턴을 활용하라.

-> 무조건 해놓으면 좋다. 요즘 IT에서는 디자인패턴 용어를 아는 것을 좋아하더라. 잘난척 한다고 생각하지 않는다.

### 디자인 패턴의 문제점
- 유연성을 확보하기 위해
	- 비기능적 요구사항, 품질속성을 위해, 퍼포먼스를 위해 다형성 쓰지 말고 직접 참조
	- 이렇게 설계한 경우 rational이 필요하다.
	- trade off에 대한 엄밀한 판단이 필요하다.

## UML을 활용한 디자인 패턴

### 유도탄 발사
- 밸브 개방
- 가역
- 비가역
- 탄 이탈
![[Excalidraw/LIG Nex1 방산 소프트웨어.md#^group=IsALSGuiKExySEoOYWF8k]]
- VLS virtical... Missle ....
- SAAM....
- state가 많다. 각 상태에 따라 어떤 동작을 수행해야 하는지, 어떤 값을 세팅해야 하는지.
- CLT: 지령 송신기 -> 지령에 따라 if else if ....  이렇게 하면 퍼포먼스 
	- 조건문을 객체화 하라. -> strategy 패턴을 적용 -> 클라이언트를 알 필요가 없다.
	- state 패턴은 클라이언트를 알아야 한다.

- [ ] [[RS422]]통신도 많이 씁니다. 🆔 취업

## 참조도서
- APPLYING UML AND PATTERNS
- UML 2 AND THE UNIFIED PROCESS
- UML DISTILLED THIRD EDITION
- Design Patterns Elements of Reusable Object Oriented Software

- 배운 것들을 복습 하면서...
- 객체지향의 LSP OCP, 추상화만이라도
	- 강사 - 교육생 = 전파진흥협회 비즈니스
	- 강사와 교육생은 객체, 스스로 구현

- [ ] OCP를 해서 CRUD를 제공하는 원칙을 제공해서 구현하도록...하기
	- 코드가 중복되는 것은 라이브러리화....
	- 지원 부서 타겟팅을 잘하자...
	- 잘한 거 못한 거... -> 못하는 거 블러핑 하면 무조건 다 걸림..
	- 나머지는 운

---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
