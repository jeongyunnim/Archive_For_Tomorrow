---
날짜: 2025-01-07
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 윤소영
aliases:
---
### 날짜:  2025-01-07 09:15

### 태그: #프로그래밍/임베디드

>[!메모]
>

### 원문
---
# 3.7 포인터
### 메모리의 주소
- 주소는 변수가 할당된 메모리의 시작 주소이다.
- **주소값**과 **타입**이 중요하다.
	- 주소값 `0x1000`
	- 타입(int, float 등)
- void pointer
	- vp + 1 같은 연산 또한 할 수 없다.
	- 사용할 때 타입을 명시해야 사용할 수 있다.
```c
void* vp = &a;
// (void *)&a;
(char *)vp;
```
- 포인터 변수는 크기와 상관없이 변수의 시작 주소만 저장한다.
### 주소 연산자 `&`
- 변수가 할당된 메모리 시작 주소를 알 수 있다.
	- 변수에만 사용할 수 있다.
	- `&10`같은 것을 사용할 수 없다.
### 포인터 변수 `*`
- 선언 시
	- `modifier` 라고 한다.
- 사용 시
	- `참조 연산자`라고 한다.
- 형을 변환한 포인터의 대입이 가능하다.
```c
double a = 3.4;
double *pd = &a;
int *pi;
pi = (int *)pd;
```
- a와 a + 1은 다르다.
	- 배열 포인터와 포인터 변수
```C
int a[3][4];
printf("%d %d\n", sizeof(a), sizeof(a + 1));	
// 48 4
```
### 간접 참조 연산자 `*`
- 포인터로 가리키는 변수에 접근할 때 `*`를 사용한다.
- L-value와 R-value
	- L-value로 pointer가 오면 값을 쓰려는 쓰기모드
	- R-value로 pointer가 오면 값을 읽어오는 읽기모드
```c
// L-value
*ap = 20;
// R-value
b = *ap;
```

> [!warning] 포인터 사용시 주의점
> `int *ap, bp;`형식으로 선언된 변수
> bp는 포인터가 아니다.
> `int *ap, *bp;`로 지정해야한다. 
> 
> **사용하지 않는 것이 좋다.**
> 줄을 구분하자.

### strcat()
```c
char * strcat(char *s, const char *append) {
	char *save = s;
	
	for (; *s; ++s);
	while ((*s++ = *append++));
	return save;
}
```

### 함수 포인터
- 함수의 이름 또한 **포인터 상수** 이다.
- 함수의 이름이 주소이기 때문에 함수 호출 전에 함수의 정의 또는 선언이 있어야 한다.
```c hl:3
int main(void) {

	int (*cal[4])(int, int) = {add, sub, mul, divi};
	int lhs, rhs, res;
	int menu;
	char* ops = "+-*/";

	for (;;) {
		printMenu();
		(void)scanf("%d",&menu);
		if (menu == 0) break;
		(void)scanf("%d %d",&lhs, &rhs);
		--menu;
		res = cal[menu](lhs, rhs);
		printf("%d %c %d = %d\n", lhs, ops[menu], lhs, res);
	}
	return 0;
}

```
#### Left-Right, Right-Left 적용
```c
int (*(*ap)())();
```
![[Excalidraw/LIG Nex1_embedded_C.md#^group=F0pXtPxN]]
- 함수 선언 시 반환 타입을`int(*)() function()` 처럼 사용할 수 없다.
	- 함수 포인터를 반환하려면 `int(* func()) ()`? [[TODO]]: 어쩌라는 거지
```c
char *(*(*var)())[10];
```
![[Excalidraw/LIG Nex1_embedded_C.md#^group=gAHUHc7l96pjNSbUG-dTZ]]
- **배열 포인터와 포인터 배열을 확실하게 구분해야 한다.**
![[Excalidraw/LIG Nex1_embedded_C.md#^group=j2AJ5LEV]]
### 2차원 배열을 1차원 배열로 캐스팅하여 사용하기

```c
int main(void) {
	int a[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
	int* ap = (int*)a;
	int i;


	for (i = 0; i < 12; i++) {
		printf("a[i][j]: %d, *((int *)a + i): %d, ap[i]: %d\n", 
			a[i / 4][i % 4], *((int *)a + i), ap[i]);
		//printf("%d %d ", (int *)a + i, );
	}

	return 0;
}
```
- 다양한 표현
	- `*a + i`
	- `(*a)[i]`
	- `a[0][i]`
	- `(&a[0][0])[i]`
	- 실제로 이렇게 쓰지는 않는다...
### 포인터의 연산
- 포인터 + 정수
	- 포인터 + (정수 * 포인터가 가리키는 타입 크기)
	- `포인터1 - 포인터2`: `주소 값의 차` / `포인터가 가리키는 타입 크기`

> [!info] pointer 끼리의 연산은 왜 타입 크기로 나누어주는가?
> len = `original_p` - `advanced_p`; 처럼 요소의 개수를 포인터끼리의 연산을 통해 얻을 수 있다.
### 배열의 이름
- 배열의 첫 번째 요소를 가리키는 **포인터 상수**
	- 포인터이기 때문에 포인터 연산이 가능하다.
	- 상수이기 때문에 대입이 불가능하다.
```c
char str1[10] = "Hello";
char str2[10];

strcpy(str1, "Hype Boy");
strcpy(str2, str1);
// strcpy("tiger", "lion") 상수는 L-value로 사용할 수 없다.
```
### 배열 등가 포인터
- 포인터 변수에 배열로 초기화하여 배열처럼 쓸 수 있다.
```c
int ary[3] = {0};
int *pa = ary;

*p = 10;
*(p + 1) = 20;
pa[2] = pa[0] + pa[1];
```
- 배열명은 **포인터 상수**, 배열 등가 포인터는 **포인터 변수**이다.
```c
int ary[3];
int *pa = ary;

sizeof(ary); // 12 바이트
sizeof(pa); // 4 바이트

// Error
ary = ary + 1;
ary++;

// OK
pa = pa + 1;
pa++;
```
- `*p++`를 많이 사용하게 될 것이다.


---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
- [[3.6 배열]]: 배열 또한 상수 포인터, 포인터와 배열이 긴밀하게 연결되어 있다.