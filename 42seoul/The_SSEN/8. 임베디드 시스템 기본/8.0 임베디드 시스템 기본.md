---
날짜: 2025-02-19
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 홍영기(guileschool@gmail.com)
aliases:
---
### 날짜:  2025-02-19 08:54

### 태그: #프로그래밍/임베디드

>[!메모]
> 

### 원문
---
# 8.0 임베디드 시스템 기본
### 들어가기 전에
- 지금 이 시간 부터는 C언어를 전면에 내세워야 한다.
	- 무조건 C언어, 닥치고 C언어
	- 임베디드 소프트웨어는 C언어로 시작해서 C언어로 끝난다.
- 이번 주 금요일 프로세서 구조 및 디바이스 프로그래밍
	- 8일 동안 진행
	- C언어 프로젝트를 할 것이다. 아침부터 저녁까지 문제, 어떤 기능을 하는 프로그램을 만드시오.
		- 평가 + 피드백
- 15년 경력의 강사
	- 원동력: 이 일을 사랑했기 때문에
	- 강사 이전: 12년 경력 개발자
	- 개발은 왜 그만뒀는가?: 어느 순간 재미가 없었다.
	- 강의가 적성이 맞았다.
### 교육 목표
- 임베디드 시스템이 무엇인가?
## 임베디드 시스템 개론
### 임베디드 시스템 정의
- **특정한 목적**을 수행하기 위해 디자인된 컴퓨터 시스템
	- 자동차, 가전제품, 디지털 카메라, ATM, 스마트폰, 드론, 로켓 등
- PC는 임베디드 시스템이라고 하지 않는다.
	- 범용으로 사용하기 때문
### 임베디드 시스템의 특징
- 특정 목적에 최적화
	- 특정 기능을 수행하는 것에 중점
	- **필요한, 최적화된** 하드웨어와 소프트웨어만 가지고 있다.
	- 하드웨어와 소프트웨어가 결합된 시스템
- 자원 제한
	- 제한된 메모리, 저장 공간, 컴퓨팅 파워 등을 가지고 있다.
	- 시스템 최적화가 중요하다.
- 실시간 작업
	- 모든 임베디드 실시간 시스템이다.
	- 실시간: 주어진 시간 내에 특정 작업을 완료해야 한다는 것을 의미한다.
- 내장형
	- 제품 내부에 내장되어있다.
### 임베디드 시스템의 종류

### 임베디드 시스템의 구성
- 하드웨어 + 소프트웨어(+ RTOS)
### 임베디드 시스템 하드웨어
- CPU
	- 모든 계산과 제어 작업을 담당한다.
- 메모리
	- 시스템이 실행되는 동안 **데이터**와 **명령어**를 저장하는 공간.
	- CPU가 작업을 하기 위한 값을 저장하는 공간
	- 데이터를 저장하는 메모리와 명령어를 저장하는 메모리
	- RAM: 임시적으로 저장 -> 전원이 들어와있는 동안만 동작
	- ROM: 전원을 끈 후에도 데이터를 보존한다.
		- 시스템의 부팅 코드나 필수적인 설정 값이 저장된다.
- 입출력 장치
	- 외부 세계와의 상호작용
	- 센서(모션, 온도, 조도 등), 스위치, 디스플레이, 통신 포트
- 기타 하드웨어 구성 요소
	- PAL, PLD, 외부 메모리, NIC 등

### 임베디드 시스템 소프트웨어
- 특화된 기능을 가진 제품을 위해 맞춤형 코드를 작성하는 과정
- 개발 과정
	- 시스템 요구 사항 정의
	- 적절한 하드웨어, 소프트웨어 선택
	- 시스템의 세부 기능을 위한 코드 작성
	- 테스팅과 검증
	- 실제 제품에 적용
- 장치의 특성에 따라 RTOS를 사용하는 경우가 있다.
### 임베디드 시스템 개발 환경
- 호스트 / 타겟 -> 개발 PC -> 보드
- 상호 작용의 수단
	- 물리적 연결
- 3가지의 전송 방법 
	- [[ICE]] 또는 [[JTAG]] 케이블
		- JTAG: 프로그램이 실행되는 타겟보드를 개발 PC에서 디버깅을 해볼 수 있도록 한다.
	- Serial 케이블
		- 프로그램 작성 시, 타겟 시스템에서 실행할 것이기 때문에 컴파일된 프로그램을 보낸다.
		- PC에서 연결해서 타겟 시스템의 출력을 연결된 시리얼 케이블 포트로 연결한다.
		- 속도가 느리다.
	- Ethrernet 케이블
		- 파일이 클 때는 serial 대신 Ethernet 케이블을 사용한다.
![[Excalidraw/LIG Nex1 임베디드.md#^group=GGQdeUTDWfNgJOyvxsoxU]]
### 임베디드 시스템 개발 환경
- 하드웨어
- 개발도구
- 소프트웨어
- 테스트 및 디버깅
### 임베디드 시스템 운영체제
- 실시간 운영체제 vs 리눅스 운영체제
	- 이때 사용되는 리눅스는 임베디드 리눅스라고 한다.
	- 전반부 RTOS
	- 후반부 임베디드 리눅스
- **임베디드 소프트웨어의 3가지 개발 방법**
	- 펌웨어 개발(베어 메탈 프로그래밍)
		- 제일 쉽다. + 고인물이 많다.
	- RTOS
	- 임베디드 리눅스
		- 악마스럽다.
### 실시간 임베디드 시스템
- 리얼타임 시스템
	- 정해진 시간 내에 임무를 수행하는 시스템
- **소프트 리얼타임 시스템**
	- 가능한 한 빠르게 임무를 수행하지만, 반드시 정해진 시간 내에 수행할 필요는 없다.
	- timeout인 경우에도 계속 수행
	- 동영상 플레이어, 커피 자판기, 전화기 등 
- **하드 리얼타임 시스템**
	- 어떤 사건이 발생했을 때 정확히 동작해야 한다. + 반드시 정해진 시간 내에 임무를 마쳐야 한다.
	- timeout인 경우 failure -> 잘못되면 큰일나는 경우
	- 인공위성, 미사일 제어, 원자력 발전소
### 실시간 운영체제 RTOS
- 특정 작업을 정해진 시간 안에 정확하게 처리할 수 있도록 설계된 운영체제
- 제한된 시간 안에 반응하거나 작업을 완료해야 하는 실시간 응용프로그램에 사용된다.
- GPOS: General Purpos OS
	- windows / linux
- RTOS는 어렵다..
	- 디버깅을 할 수 있어야 한다.
	- 까다로운 문제에 봉착할 확률이 높다.
- 원래의 목적은 실시간을 위해 만든 것이 아니다.
	- 임베디드 안에서도 OS가 있었으면 좋겠다는 생각으로 개발되었다.
	- 하드 리얼타임에서 필요하기 때문에 사용하는 것이 아니다.
#### 결정적인 타이밍 Deterministic timing
- 작업이 완료될 때까지 걸리는 시간을 예측할 수 있어야 한다.
	- N초 안에 완료되어야 한다는 기준이 있어야 한다.
	- 예상치 못한 동작을 하거나 성능이 안나올 수 있다. -> 개발자 탓
#### 멀티태스킹 Multitasking
- 여러 작업이나 프로세스를 동시에 실행할 수 있어야 한다.
	- 각종 연산, 출력 등의 동작을 시분할 방식을 통해 동시에 수행한다.
![[Excalidraw/LIG Nex1 임베디드.md#^group=wLkOkRcVGphNXe8YD7UQA]]
#### 우선순위 기발 스케줄링 Priority-based scheduling
- 작업에 우선순위를 부여하여, 가장 높은 우선순위를 가진 작업부터 처리하는 스케줄링
#### 기타 특징
- 최소한의 지연시간
- 메모리관리
- 등
### RTOS 종류
- Wind River(VxWorks)
	- 방산에서 가장 많이 사용한다.
	- 가장 탁월한 성능을 보인다.
		- NASA의 프로젝트에서 사용하는 OS
		- 실시간성이 중요하기 때문에
- QNX
	- 자동차 쪽에서 많이 사용한다.
- FreeRTOS
	- 무료
	- 얘를 다룰 줄 알면 VxWorks도 다룰 수 있다.
### 임베디드 시스템의 전망
- 임베디드 시스템은 기술 혁신의 중심에 위치한다.
	- 기술을 배우고나면 나중에 창업이 가능하다.
- 인공지능과 머신러닝의 활용도 증가
- IoT와 연결성
- 에너지 효율성
- 보안
- 5G와 발전하는 통신 기술
## 임베디드 시스템 설계
### 임베디드 시스템 제작 과정
- 공학적 절차를 따르는 복잡한 과정이다.
- 요구사항 정의
	- 라디오 기능, 다국어 지원 등 요구사항 수집
	- 제약 사항 정의
	- 필요한 기능과 성능 요구사항 명세
- 설계
	- 적절한 하드웨어와 소프트웨어 구성요소
	- 시스템 전반적인 구조를 설계
	- 시스템 주요 구성 요소, 인터페이스 등의 설계를 수행한다.
- 구현
- 테스팅
- 디버깅
- 최적화
	- 시스템 성능을 향상시키기 위해 하드웨어와 소프트웨어를 최적화한다.
	- 안 쓰는 기능의 클럭을 차단해버리면 전력 소모를 안 먹는다. 소비 전력을 확 줄일 수 있다.
- 유지보수
### 임베디드 소프트웨어 개발 환경
- 하드웨어
	- 특정한 하드웨어 위에서 동작하기 때문에 해당 하드웨어에 대한 깊은 이해가 필요하다.
	- 많이 알고 있을 수록 유리하다.
- 임베디드 운영체제
- 프로그래밍 언어
	- C/C++/Assembly와 같은 저수준 언어로 작성
	- 하드웨어에 직접 접근하고 자원을 효과적으로 관리하는 데 유리하다.
- 크로스 컴파일러
	- 임베디드 시스템은 PC와 다른 아키텍처를 사용하기 때문에, 소스코드를 타겟 하드웨어에서 실행 가능한 바이너리 형태로 변환하기 위한 컴파일러가 필요하다.
### LED 실습
- STM32F429I-DISC1
	- ST사에서 만든 칩을 사용하고 있다.
	- DISC = discovery
- 실습 환경
	- v1.12.0 - 로그인 필요하지 않음
	- ---- 로그인 필요
	- v1.13.0
	- ...
	- v1.17.0은 똥이다. 버그 천지.
- ARM
	- 비메모리 반도체(CPU) 회사
	- 설계 기술을 가지고 있다. - 영국
	- 2005년도 CORTEX-A, R, M을 release
	- 이 라이센스를 받아서 많은 반도체 회사들이 제조를 시작했다.
		- TI, ST, SAMSUNG, OKI...
- ST사 CORTEX-M을 내장한 프로세서: STM32
	- eg. STMF429ZI-DISC1
- HAL
	- 라이브러리는 보통 컴파일된 바이너리가 archive로 제공된다.
	- HAL library는 소스코드로 제공된다.
### 임베디드 소프트웨어 개발 환경
- 디버깅 도구
	- JTAG 디버거 aka ICE
	- 오실로스코프
	- 로직 분석기
- 버전 관리 시스템
	- GIT, SVN
- 자동화 도구
	- make, CMake

### 임베디드 소프트웨어 실행 파일 생성 과정
- IDE 추천
	- VSCODE
	- SUBLIME-TEXT
	- VI(VIM)
- 컴파일이 무엇인가?
	- 실행파일이 만들어지기 까지 일련의 과정
- OBJ 파일 -> 실행할 수 있는가?
	- startup code가 없기 때문에 실행이 불가능하다.
	- 컴파일러는 start.o를 가지고 있다.
	- [ ] 언제 start.s를 컴파일 하는가?
![[Excalidraw/LIG Nex1 임베디드.md#^group=WyxQpUnmvWYVEYBUCEaC9]]
### [[JTAG]] 인터페이스
- 디버그용 개발 장비
- 핀을 통해 신호가 들어오거나 나간다.
	- 0 -> LOW
	- 1 -> HIGH
- 외부에서 신호가 0인지 1인지를 알 수 있게 된다.
	- 핀을 통해 들어온 값은 연결된 레지스터에 저장이 된다.
	- 출력으로 내보내는 값 또한 연결된 레지스터에 저장된다. 
	- JTAG은 레지스터의 값을 읽어서 출력한다.
- STM -> 디버깅 시 trace를 활용한다.
	- C언어 핵심: 포인터 + 배열 + 구조체
### LED 디버깅
- 문제가 있을 것이라 추정되는 코드 사이에 LED 점등 코드를 삽입하여 버그를 잡는다.
- 부트코드 디버깅 시 유용하다.
- 개발 도구가 없을 때 사용한다.
	- 개발 도구가 있다면 중단점을 걸거나 trace를 통해 접근하는 것이 훨씬 쉽다.
- 해커들이 printf 디버깅을 좋아하는 이유
	- 어마어마한 이유가 있다.
### 74 시리즈
- 디지털 전자회로에서 일반적으로 사용되는 [[TTL 논리 소자|TTL]](Transistor-Transistor Logic)
	- 논리회로, 카운터, [[Flip-flop]], [[MUX]], 디코더 등을 제공한다.
- LS(Low-power Schottky), HC(High-speed [[NMOS와 CMOS|CMOS]]), HCT(Hich-speed CMOS, TTL-compatible) 등은 전력 소모, 속도, 입출력 특성 등 다른 특징을 갖는다.
- 74LS {논리회로, 카운터...} 를 검색하면 이미 구현된 회로도를 확인할 수 있다.
### 프로그램을 ROM에서 실행하기
- ROM: Read Only Memory
- 리셋 후 프로세서는 0x0
- 메모리의 종류
	- RAM: 변수를 저장
	- FLASH: 프로그램이 들어간다.
![[Pasted image 20250219164536.png]]

- 프로그램은 램에서 실행할 수도 있다.
	- 롬에서 램으로 복사하여 실행할 수도 있다.
	- 상세한 설명은 이후에 프로세서 구조 수업에서 들어간다.
- 양산 시 ROM writer를 사용하는 경우가 더 효율적이다.
### **레지스터 구조**
- 레지스터란
	- 컴퓨터의 프로세서나 I/O 내에서 자료를 보관하는 아주 빠른 기억 장소
- 하드웨어 레지스터
	- GPIO
- 프로세서 레지스터
	- 하드웨어 레지스터와 다르다.
- N번째 비트를 지칭하는 법
	- N번 비트
- 2진수를 외워야 한다.
	- 16진수 <-> 2진수
### 16진수
- 2진수를 사용할 수 없기 때문에 궁여지책으로 16진수를 사용할 수밖에 없는 것이다.
- [ ] 양방향 변환을 자유자재로 2 <-> 16

| 0000 | 00  |
| ---- | --- |
| 0001 | 01  |
| 0010 | 02  |
| 0011 | 03  |
| 0100 | 04  |
| 0101 | 05  |
| 0110 | 06  |
| 0111 | 07  |
| 1000 | 08  |
| 1001 | 09  |
| 1010 | 0A  |
| 1011 | 0B  |
| 1100 | 0C  |
| 1101 | 0D  |
| 1110 | 0E  |
| 1111 | 0F  |
### 자주 사용하는 논리회로
- AND
	- C연산자의 `&`
	- ZERO(MASK `0`)
	- COMPARATOR
		- 임의의 값을 비교하는 비교기
	- 
- OR
	- C연산자의`|`
	- ONE (MASK `1`)
- XOR
	- C연산자`^`
	- TOGGLE
	- SET to ZERO
### 비트 연산
- 비트의 위치 선정
	- 레지스터 형태를 떠올려야 한다.
	- `rGPECON = (0x3 << 21)`
		- 21은 shifter라고 한다.
	- `rGPECON >>= 16`
		- 상위 16비트만 추출: 0xFFFFFFFF -> 0x0000FFFF
- 곱셈 / 나눗셈
	- `<< N`의 결과 $2^N$을 곱한 효과
	- `>> N`의 결과 $2^N$을 나눈 효과
- **선택된 비트 zero fill  마스킹**
	- `rGPCON &= ~(0xF << 22)`
		- 22, 23, 24, 25 비트를 0으로 마스킹한다.
	- `&= ~(A << B)`
		- A: 지우고자 하는 비트의 패턴
		- B: 비트 패턴의 시작 주소
- **선택된 비트 set**
	- `rGPCON |= (A << B)`
		- `rGPCON |= ((1 << 27) | (1 << 25))` VS `rGPCON |= (5 << 25)`
			- 성능에 차이가 없다 -> **어셈블리어를 배워야 하는 이유**
		- A: set 하고자하는 비트의 패턴
		- B: 비트 패턴의 시작 주소
### 메모리 3종류
- 플래시 ROM: FLASH Read Only Memory
	- 프로그램의 저장 목적
	- [ ] 플래시라는 이름은 어디서 왔는가?
	- 읽기, 쓰기가 가능하다.
		- 쓰기가 가능한 시점에만 쓸 수 있다.
	- 속도가 느리므로 동적 데이터를 보관하는 것은 좋지 않다.
	- 전원이 꺼진 후에도 보관해야 하는 장기데이터
- SRAM: Static Random Access Memory
	- 메모리 액세스 시간이 DRAM보다 빠르다.
	- 가격이 비싸다.
	- 고속 메모리 및 캐시 같은 고속 작업에 사용된다.
- DRAM: Dynamic Random Access Memory
	- 클럭을 이용한 충방전(refresh)이 필요하다.
### [[MCU]]를 선택할 때 고려해야할 것들
- 처리 능력, Processing Power
	- 제품의 필요 기능을 수행하기 위한 충분한 처리 능력을 가진 MCU를 선택해야 한다.
	- 주파수, CPU 유형, 워드 크기, 부동소수점 유닛([[FPU]]) 유무 등
- 메모리 용량
	- 충분한 RAM과 Flash 메모리
- 통신 인터페이스
	- 시스템에 필요한 통신 인터페이스
	- SPI, I2C, UART, CAN, Ethernet, USB
- 전력 소모
	- 절전모드나 빠른 시작 기능 등
	- ARM CORTEX를 사용하고 있다면 대부분 만족할 수 있다.
- 입출력 포트
	- 충분한 입출력 포트가 있는지 확인해야 한다.
- 비용
	- 가격, 개발 도구, 보드, 지원 등 전반적인 비용을 고려해야 한다.
- 공급연속성
	- 생산이 중단될 위험이 없는지 알아야 한다.
- 소프트웨어 및 하드웨어 지원
- 임베디드 보안
### OS를 선택할 때 고려해야할 것들
- 시스템 요구사항
	- 처리 속도, 메모리 크기, 사용 가능한 스토리지, 전력 소모
- 실시간 처리
	- 임베디드 시스템의 요구사항에 실시간 요구 사항이 있는 경우
	- RTOS를 통해 정해진 시간 내에 작업의 완료를 보장할 수 있고, 시스템의 예측 가능성과 안정성이 향상된다.
- 유지보수와 지원
	- 업데이트, 패치, 트러블 슈팅, 문서화, 커뮤니티 지원 등
- 비용
	- OS를 구입하거나 라이센스를 구입하는 비용, 유지 관리 및 업그레이드 비용
...
### 펌웨어, RTOS, 리눅스
- 펌웨어
	- 하드웨어를 제어하기 위한 내장형 소프트웨어
- RTOS
	- 실시간 애플리케이션을 지원하기 위해 설계된 운영체제
	- 멀티태스킹을 지원한다.
- 리눅스
	- 자유롭게 사용, 수정, 배포할 수 있는 오픈소스 운영체제
	- 최대한의 유연성을 제공하며, 다양한 하드웨어와 소프트웨어에 적용할 수 있다.
	- 실시간 확장 기능을 가진 리눅스도 있다.
- 어떤 경우에 펌웨어로 개발을 해야 하는가?
	- 일단 리눅스를 기본으로 생각하자.
		- OS를 돌릴 수 있는 리소스를 제공할 수 있는가
		- 리눅스를 다룰 수 있는 유능한 개발자(해결사)를 필요로 한다.
	- 펌웨어로 개발 하다가 멀티태스킹이 필요하다 -> RTOS를 선택한다.
### 마이크로 프로세서와 마이크로 컨트롤러
- 마이크로컨트롤러 VS [[SoC(System on Chip)]]
- 마이크로컨트롤러
	- 특정 임베디드 애플리케이션을 위한 전용 컴퓨터
## 버스와 메모리
### 버스
- 컴퓨터 내부에서 데이터, 주소, 제어 신호를 전달하는 주요 통신 경로
- 종류
	- 데이터 버스, 주소 버스, 제어 버스
	- 3가지 버스가 하쳐져서 컴퓨터 시스템의 버스 아키텍처를 형성한다.
![[Excalidraw/LIG Nex1 임베디드.md#^group=b52gnC_r_ONpbbVeNFkND]]
### 데이터 버스
- 데이터 버스는 CPU와 메모리, 그리고 다른 장치 사이에서 데이터를 전송하는 데 사용된다.
### 어드레스 버스
- CPU가 메모리 또는 입/출력 장치의 위치를 식별할 수 있도록 주소 정보를 전송하는 데 사용된다.
- 주소 버스의 너비는 시스템이 접근할 수 있는 메모리 공간의 크기를 결정한다.
	- 어드레스 라인 수가 19개인 경우 일반적으로 $2^{19}$ == `512KB` == `0.5MB` 이다.
### 제어 버스
- 데이터 읽기
	- OE(output enable) 신호가 Enable 되어야 읽기 가능
- 데이터 쓰기
	- WE(write enable) 신호가 Enable 되어야 쓰기 가능
- 칩 선택
	- CE
![[Excalidraw/LIG Nex1 임베디드.md#^group=g3cP_TOh-SSgTryKPEkJF]]
- Onchip
	- 칩 내부에 내장되어 있는 Peripheral
	- RTC, 내부에 내장 되어있으면 Onchip RTC, 바깥에 있으면 Offchip RTC
	- 칩 내부에 있는 버스를 통해 상호작용한다.
		- 온칩버스
- 버스에 연결된 장치
	- 프로세스 코어 - 버스 마스터
		- 다른 디바이스와 데이터 전송을 시작할 수 있는 논리 디바이스
	- 주변장치 - 버스 슬레이브
		- 버스 마스터의 요청에만 응답하는 논리 디바이스
	- [[DMA]]는 마스터와 슬레이브 둘 다 될 수 있다.
### `C = A + B` 프로그램의 실행
- 임베디드 개발자는 C언어 개발자와 달라야한다.
	- 코드를 보고도 내부에서 일어나는 동작을 그릴 수 있어야 한다.
- 메모리의 용도
	- 프로그램을 저장
	- 데이터를 저장
- [ ] CPU에 의해 만들어진 신호들이 메모리로 들어가는 과정
### 폰노이만 아키텍처 VS 하버드 아키텍처
- 액세스
	- 읽기와 쓰기를 동시에 이야기할 때
	- 폰 노이만 아키텍처는 롬과 램을 동시에 액세스할 수 없다.
- 최근에는 더 우수한 하버드 아키텍처를 사용한다.
### 버스 신호의 네이밍 규칙
- [[Clock]] 신호
![[Excalidraw/LIG Nex1 임베디드.md#^group=ffr__3Niih4eywVkFCYRu]]
- HIGH, LOW 여기까지만 알면 된다.
	- 제어신호에서만 사용하는 용어
- HIGH ACTIVE 신호
	- HIGH일 때 의미가 있는 신호
- LOW ACTIVE 신호
	- LOW일 때 의미가 있는 신호
	- /CS, INT*, nRESET, NACK, BREQ#
![[Excalidraw/LIG Nex1 임베디드.md#^group=G3hFv-qOe-Z_ZNKw7pYrS]]
- 칩 선택 신호 이름은 다를 수 있다.
	- CE: Chip Enable
	- CS: Chip Select
### 메모리버스 인터페이스 - 32비트
- BCLK, RD/$\bar{WR}$
	- 버스 마스터가 클럭을 공급한다.
	- 신호가 오른쪽으로만 나간다.
- `D[7-0]` <-> L1
	- BYTE LANE
	- 4개가 있다. 32비트 프로세서
- 대역폭이 4개로 늘어났으므로 입출력 성능이 향상
- 메모리 연결 방법...
	- 이거 자체가 중요한 것은 아니고, 개념을 잡는 수단으로써 이용하자.
- 외워두면 좋은 수
	- $2^4 = 16$
	- $2^{10} = 1K$
	- $2^{16} = 64K$
	- $2^{20} = 1M$
	- $2^{24} = 16M$
	- $2^{32} = 4G$
- 8비트 메모리를 사용했지만, 4개를 병렬로 연결하여 32비트 메모리처럼 동작하게 할 수 있다.
	- CS 신호를 동일하게 사용한다.
	- 32비트 입출력이 가능하다.
	- 징크보드 -> 상위 레벨의 스킬을 요구한다.
		- 설계에서 많이 사용되는 보드
		- 외부에서 연결 시 까다롭다.
### 어드레스 디코딩
- [ ] 어드레스 디코딩, 핵심..
- CS가 같으면 병렬, 다르면 직렬
- 병렬이 아니면 접근하려는 주소를 같게 연결한다.
- `0x2F001234` = `0x2F000000` + `0x1234`
	- `0x2F000000`: BASE 주소
		- 상위 주소로 직렬로 연결된 메모리 중 어떤 메모리에 접근할지 결정한다.
	- `0x1234`: OFFSET 주소
- 직렬로 연결시 어드레스 디코딩이 필요하다.
	- 서로 오버랩 되지 않도록 한다.
### 메모리 맵
- 어드레스 디코딩과 불가분 관계
- 메모리 컨트롤러
	- CS 신호를 만들어 낸다.
- 임베디드 시스템에서 메모리맵은 일반적으로 프로세서와 연결된 각각의 물리적인 메모리 장치와 I/O 장치를 참조하기 위한 주소 공간의 분포를 보여준다.
### 메모리 컨트롤러
- SRAM은 개발자가 제어를 해야 제 성능을 낼 수 있다.
- 메모리 컨트롤러는 특정 메모리 장치를 활성화할 수 있도록 한다.
	- CS 신호
### 오퍼랜드 크기 종류
- WORD

### 메모리 계층구조
- 레지스터
	- 프로세스 코어의 필수요소
	- 시스템에서 가능한 가장 빠른 엑세스를 제공
- 캐시 메모리
- 주 메모리
- 보조 메모리
#### disassembly 란
- 실행 파일이 만들어지는 과정
	- 소스코드 -> 컴파일 -> 어셈블리어 -> 기계어
- 기계어를 역어셈블링을 한다.
	- symbol 정보가 남아있다.
	- 소스코드와 레지스터 정보를 가지고 구성한다.
### [[PAL]]과 [[PLD]]
- 22v10 또는 GAL
- PAL
	- Programmable Array Logic
- PLD
### 캐시 메모리
- 주 메모리와 CPU 간의 속도 차이를 극복하기 위한 빠른 메모리
- 자주 사용되는 데이터나 명령어를 저장해둔다.
- CPU가 메모리에 접근하는 경우
	- 머신코드 또는 데이터를 읽기 위해
- cache memory
	- Zero wait: 기다리는 시간이 0이다.
	- 함수가 통째로 캐시 메모리에 있으면 성능이 매우 좋아질 것이다.
	- 적어도 2배, 크게는 10배 이상의 성능이 좋다.

- 왜 빠른가?
	- 시간 참조의 원리
		- 최근에 참조된 주소의 데이터는 가까운 미래에 다시 참조될 가능성이 높다.
		- 루프 구조에서 반복적인 실행
	- 공간 참조의 원리
		- 어떤 주소의 데이터를 참조할 때 주변 주소의 데이터도 곧 참조될 가능성이 높다.
		- `int i, j;` 캐시 적중률을 높이려면 이렇게 선언하는 것이 좋다.
		- 필요가 있든 없든 뭉탱이로 가져와서 캐시메모리에 쌓아놓는다.

### 가상 메모리
- 물리주소
	- 가상 메모리가 있을 때 의미가 있다.
	- 가상 메모리를 지원하지 않는 경우는 그냥 주소라고 해야 한다.
- 가상 메모리
	- 리눅스 운영체제는 가상메모리를 기반으로 돌아간다.
		- [ ] 리눅스만 가상 메모리를 지원하는가?
	- 물리주소와 매핑되는 가상 주소를 제공한다.
	- [[MMU]]: 가상주소를 물리주소로 바꾸는 일만 수행한다.
### 메모리 맵핑 I/O와 포트 맵핑 I/O
![[Excalidraw/LIG Nex1 임베디드.md#^group=imu3jscC]]
- 메모리 맵핑 I/O
	- 주변장치를 위해 일정한 메모리 주소 공간을 할당하는 방식
- 포트 맵핑 I/O (IO Mapping I/O)
	- 잘 안 쓴다. 메모리 맵핑 I/O를 주로 사용한다.

## 임베디드 시스템 최적화
- 용어와 모습을 기억하자.
### 인라인 어셈블리
- 소스 코드에 직접 저수준 어셈블리 코드를 삽입하는 기술
- 속도 향상, 하드웨어 특정 명령어의 사용, 특별한 프로세서 명령을 수행하는 데 장점을 가진다.
	- C언어는 만능이 아니다. (99%)
	- 1%는 어셈블리어로 채워야 한다.
### 임베디드 시스템 최적화
- **처리 성능 최적화**
	- CPU성능은 100% -> 150%가 나오도록 하는 것
	- CPU 클럭 스피드가 500M -> 600M로 올렸다? 성능을 끌어올린 것. 최적화가 아니다.
	- 코드 최적화, 캐시 메모리 사용량 최적화, 병렬 처리 등
	- `-O`
- **메모리 사용 최적화**
- 에너지 효율 최적화(전력 소비)
	- 일반적이지는 않다.
### 테이블 룩업
- 미리 계산된 값을 저장하고 사용하라.
### 레지스터 변수
- `register` 키워드로 변수를 선언하는 것
	- CPU의 레지스터 영역을 변수 전용으로 하나 사용하게 해달라고 하는 것.
	- 하나 정도만 등록하는 것이 일반적이다.
	- 두 개도 많다.
- 가장 빠른 메모리를 이용하기 위함
### 전역 변수를 사용하기
- 메모리가 작은 프로그램에서는 전역변수를 활용해야만 한다.
	- 스택의 크기가 작아서 어쩔 수 없다.
- 속도가 빠르다. 
	- 원하는 위치에서 빠르게 접근이 가능하다.
- 위험
	- 코드의 유지보수가 어렵다.
- [ ] static을 사용하는 이유 5가지
	- 많이 쓸수록 좋다.
### 임베디드 시스템 공간 최적화
- 램사용량을 줄이는 것이 목표이다.
- 정적할당을 사용하여 메모리 누수를 피하고, 동적할당은 필요할 때만 사용한다.
- 프로그램의 크기를 줄이기: 함수와 루틴의 재사용
- 불필요한 라이브러리 호출을 제거하기
### ROM 사용량 줄이기
- 임베디드 시스템의 ROM 사용량을 줄이기 위한 몇 가지 방법
- 불필요한 코드 제거
- 코드 재사용
- 컴파일러 최적화 `-O` 옵션 활용
- 상수 데이터 및 초기화 데이터를 ROM에 저장
	- `float pi 3.14f;` 바꾸지 않을 거라면 const를 붙여서 ROM에 생성되도록 하라
- 불필요한 데이터 제거
	- 사용하지 않는 테이블, 배열, 문자열 등
- 라이브러리에서 필요하지 않은 기능을 제거
- 최소한의 기능만 지원하는 라이브러리를 사용
### RAM 사용량 줄이기
- 정적할당 사용하기
	- RTOS에서 학습
	- 동적할당을 안 쓰면 아예 힙을 사용하지 않을 수 있다.
- 메모리 풀 사용하기
	- 미리 정의된 크기의 메모리 블록을 가지는 풀을 만들어 해당 풀에서 할당 및 할당 해제
	- 메모리 단편화 최소화
- 작은 스택 사용
	- 각각의 스레드나 태스크의 스택 크기를 최소화하여 RAM을 절약
- 

---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
