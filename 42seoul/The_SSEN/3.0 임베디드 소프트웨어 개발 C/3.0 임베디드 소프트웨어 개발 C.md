---
날짜: 2025-01-02
넘버: 
태그: 프로그래밍/임베디드
출처: 
강사: 윤소영
aliases:
---
### 날짜:  2025-01-02 09:09

### 태그: #프로그래밍/임베디드 

>[!메모]

### 원문
---
# 3.0 임베디드 소프트웨어 개발 C
[[3.1 변수]] 
[[3.2 표준 입력]]
[[3.3 연산자]]
[[3.4 자동 형변환]]
[[3.5 제어문과 함수]]
[[3.6 배열]]
[[3.7 포인터]]
[[3.8 C 프로세스의 메모리 사용]]
[[3.9 구조체]]

### C언어란?
![[LIG Nex1_방산의_이해_OS#^group=tW1CQQOt]]

### 10진수 -> 2진수
- 임베디드 개발자는 **진법 간의 변환이 빨라야 한다**.
- decimal
- octa
- hex
```
10 A 1010
11 B 1011
12 C 1100
13 D 1101
14 E 1110
15 F 1111
```

> [!tip] 코딩하기 좋은 폰트
> D2Coding

### x64, x86
- x86: 32비트 운영체제
- x64: 64비트 운영체제

### SDL 검사 -> off
- 입출력 함수(scanf, printf)를 쓸 수 밖에 없다.
- Security Development Lifecycle

### Visual Studio 2022 community
- 실행: ctl + F5

## 문자열
### scanf(), gets(), fgets() [[TODO]]
### 문자열 배열과 문자열 상수(포인터)의 차이

| 구분  | char pointer          | char array               |
| --- | --------------------- | ------------------------ |
| 초기화 | `char *pc = "mango`   | `char str[80] = "mango"` |
| 대입  | `pc = "banana"`       | `strcpy(str, "banana")`  |
| 크기  | `sizeof(pc)`: 4byte   | `sizeof(str)`: 80byte    |
| 수정  | `pc[0] = 't';`(X)     | `str[0] = 't';`(O)       |
| 입력  | `scanf("%s", pc);`(X) | `scanf("%s", str);`(O)   |
- [[TODO]]: 문자열 상수의 값을 변경한 뒤에 주소 찍어보기

```c hl:4
int main(void) {
	char *ch = "melon";

	printf("%c", ++(*ch)); // 포인터 상수의 값을 변경할 수 없다.
	return 0;
}
```

### 연산자 우선순위를 보자.
- b는 무엇일까
```c hl:4
int main(void) {
	int a = 0x61626364;
	char *b = &a;
	printf("%X", *(int *)b);
	return 0;
}
```
- 단항은 이름에 가까운 것 부터 실행한다.
- 후치 -> 전치

```c
char arr[10] = "abced";
char *a = arr;

x = *(int *)a++;
// abcd 61626364
((++(int *)a)--)
```
![[Excalidraw/LIG Nex1_embedded_C.md#^group=g5u1jVAD]]
## 변수 사용영역
- **암기해야 한다**
![[Pasted image 20250108155239.png]]
### static 변수
- compile time에 data영역에 할당 받고, 프로그램이 끝날 때 반환한다.
- chaching을 위해 사용할 수 있다.

### 레지스터 변수
- 전역 변수는 레지스터 변수로 선언할 수 없다.
- 주소를 구할 수 없다.
- 컴파일러가 결정한다.

[[TODO]]
```c
printf("%d\n", ++(*((char*)((long long*)((char*)(arr + (int)5.5) - 1) - 1)))); 

// 왜 &사용 못하게 하나요?
```

```
1차원 배열
2차원 배열
배열포인터
포인터배열
2중/3중 포인터
```

## 동적할당
- 
```c
int input_line(int** line) {
    int cnt;

    if (!line)
        return 1;
    (void)scanf("%d", &cnt);
    *line = (int*)malloc(sizeof(int) * (cnt + 1));
    if (*line == NULL) {
        printf("Error: Memory allocation failed\n");
        return 1;
    }
    **line = cnt;
    for (int i = 1; i <= cnt; ++i) {
        (void)scanf("%d", *line + i);
    }
    return 0;
}

int optimus_input_line(int** line) {
    int cnt;
    int* l;

    if (!line)
        return 1;
    (void)scanf("%d", &cnt);
    l = (int*)malloc(sizeof(int) * (cnt + 1));
    if (l == NULL) {
        printf("Error: Memory allocation failed\n");
        return 1;
    }
    *l = cnt;
    for (int i = 1; i <= cnt; ++i) {
        (void)scanf("%d", l + i);
    }
    *line = l; // 저장한 포인터 변수를 line에 초기화해준다.
    return 0;
}
```

### realloc()
- 기존  주소 뒤에 충분한 공간이 있다면, 기존 주소 뒤에 메모리를 확장한다.
	- [[Heap 관리 테이블]]에서 사용 공간의 크기만 확장한다.
- 기존 주소 메모리가 확장하기에 충분하지 않다면 다른 공간에 연속 메모리를 할당하고 데이터를 복사하여 새로운 메모리의 첫 주소를 반환한다.
	- 기존 주소가 변경되었을 수 있기 때문에 갱신이 필요하다.
- 새로운 메모리 할당이 불가능한 경우 기존 주소의 변화없이 NULL 반환
	- `p = realloc(p, 200)`
	- realloc이 NULL을 반환하는 경우, 기존 주소를 잃어버린다.
	- 기존 주소를 임시로 저장한 뒤 NULL이 아닌 경우에만 주소를 갱신해준다.
## 입력 받을 시 주의 사항
```c hl:6
void init_data(char ***str, int *N) {
	char** str_temp = 0;
	
	if (!str || !N)
		return;
	(void)scanf("%d ", N); // 공백을 줘서 white space를 제거
	// getchar(); -> 개행을 읽어들인다.
	str_temp = (char**)malloc(sizeof(char*) * *N);
	if (!str_temp)
		return ;
	for (int i = 0; i < *N; ++i) {
		get_line(str_temp + i);
		if (!str_temp[i]) {
			free_all(*str, *N);
			exit(1);
		}
		printf("%d: %s\n", i, str_temp[i]);
	}
	*str = str_temp;
}
```

## 형 재정의
### typedef
- 기존 자료형을 새로운 이름으로 재정의 할 수 있다.
```c
int a; 
typedef int MYINT;
MYINT b;
```
- `int arr[5]`를 하나의 타입으로 정의하고 싶다면?
```c
typedef int I5A[5];

ISA a; // == int a[5];
ISA a2[3]; // == int a[5][3];
```
- 함수에서 return 하거나, 파라미터로 전달 받을 때, typedef를 통해 가독성이 더 좋은 코드를 작성할 수 있다. [[TODO]]: 어떻게 할 건데
```c
typedef int op_t(int, int);

op_t add;
```

---
### 생각(파생된 질문/생각)

### 출처

### 연결 문서 (연결 이유)
