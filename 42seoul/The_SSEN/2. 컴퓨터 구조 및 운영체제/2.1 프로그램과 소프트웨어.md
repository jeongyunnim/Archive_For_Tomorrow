---
날짜: 2024-12-27
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 문호선
교재: 인공지능 시대의 컴퓨터 개론
aliases:
---
### 날짜:  2024-12-27 10:04

### 태그: #프로그래밍/임베디드

>[!메모]
> C 특정 기능, 기계에 맞는 전용 코드를 만드는 것.
> -> OS를 만들기 위해 개발된 언어 + 특정 기계용 컴파일러(C to Asm)를 만들었다.
> 
> C++ 범용의 코드, 틀을 만드는 것. 
> -> 확장성, 이식성의 차이

### 원문
---
# 2.1 프로그램과 소프트웨어
### Program
- pro(pre) + gram
	- 미리 정해놓은 명령어들의 모음
	- CPU가 할 일을 메모리에 적어놓은 것.
### 소프트웨어
- 프로그램 또는 프로그램 집합
- 종류
	- 응용 소프트웨어(Application)
		- 사용자가 원하는 목적에 맞도록 개발된 소프트웨어
	- 시스템 소프트웨어(OS, 운영체제)
		- 하드웨어 자원을 관리하고 응용 소프트웨어를 지원
		- 기술적으로 스케줄링만 하더라도 OS라고 부르기도 한다.
	- 임베디드 소프트웨어
		- firm ware
		- **특정 목적**을 수행하기 위해 **특정 하드웨어 기반**으로 작동하도록 설계된 소프트웨어
![[Pasted image 20241228152440.png]]
### 제품의 구성
- 하드웨어/펌웨어/소프트웨어
- 지원하려는 회사가 어떤 개발을 하는지에 따라 타겟을 잘 지정해야 한다.
![[LIG Nex1_방산의_이해_OS#^group=WUD4LXGfIC6ta57Cd2UUM]]
- 미들웨어와 운영체제가 하나의 펌웨어인 경우도 있다.
- 프로세스: program in execution
	- 실행 중인 프로그램
- 프로세서: CPU
	- 프로세스를 어떻게 스케줄링 할 것인가?
- 메모리
	- memory management
#### 하드웨어
- 예외없이 **프로세서**, 메모리, I/O 구성을 가진다.
	- CPU가 가장 중요하다.
	- 프로세서를 정하면 메모리 I/O는 따라온다.
- 리모콘에는 mycom이라는 작은 칩 - 메모리가 32K 정도 OS 올리자 하면 미친놈
	- 고정된 틀: 제한된 프로세서, 메모리, 느린 I/O
	- 펌웨어를 쓴다.
	- **[[Deep sleep mode]]**: external interrupt를 받아서 CPU가 deep sleep에서 깨어난다.
		- 부팅과 같다.
		- 깨어나면서 레지스터를 읽고 처리하고 실행하고 다시 deep sleep 상태로 전환한다.
		- 휴대폰 홀드 상태도 deep sleep 상태다.
	- [[watch dog timer]]: health check을 하도록 해서 monitoring한다.
		- 외부에서 인터럽트를 줘서 리셋을 시킨다.
	- 부팅 시 PLL, 클럭 설정
#### 펌웨어
![[LIG Nex1_방산의_이해_OS#^group=CNpfkjBBmUyfTckxwBcuj]]
- 통째로 하나의 프로그램으로 짜는 것.
	- RTOS 펌웨어에 멀티태스킹을 넣은 것.
	- 하나의 실행파일, 바이너리 파일.
		- 빌드과정 ([[C runtime Environment]])
- 하드웨어에 맞춰 실행하도록 한다.
	- 롬에 맞게 올라간다.
- CPU 18MHz: CPU에 들어가는 클락이 18MHz
- 반드시 OS에 대해서 알아야 한다.
	- **나는 하드웨어/OS 지식 다 쌓아야 해.**

> [!tip] 개발의 가지
> OS의 위와 아래로 갈라진다.
> **위**: 운영체제가 포팅(이식)된 상태에서 개발
> - 편리하다, 소비자와 직접 연관, 자동화가 되면 개발이 힘들어진다.
> - 하드웨어의 발전에 따라 영향이 커진다. 현재는 생성형 AI에 의해 도태될 위기. 대체가 쉽다.
> 
> **아래**: 임베디드 - 하드웨어
> - 커널이나 하드웨어 쪽의 변화를 대응할 수 있어야 하기 때문에 성장이 가파르다.
> - 상대적으로 하드웨어가 종류가 매우 많다.
> - 호환성을 고려해야 한다.

### 언제 F/W에서 OS 도입을 검토해야 하는가?
- 회사에서 제공해준 틀 안에서 코드를 작성해야 한다.
	- 기능으로만 보아서는 안된다.
	- 임의로 효율적으로 고쳤다가 낭패를 본다.
```
while(1) {
	// 센서: 감지가 되고 안 되고에 따라 cycle이 다르다.
	// 키
	// 주기
	// 통신
	...
}
```
- 일반적으로 정해진 시간 100~200ms 정도 안에만 만족하면 된다.
	- 기능이 추가되면 만족할 수 없을 수 있다.
- RTOS에서는 동작 하나하나가 Task라고 부른다.
	- airback 같은 task와 break를 동시에 동작하도록 해야 한다?
- 펌웨어로 불가능한 경우 OS를 도입 검토해야 한다.
	- 파일 시스템 구현?
	- 네트워크 TCP/IP 구현?
	- 멀티미디어 처리?
	- 이러한 문제를 **호환성**문제로 일축할 수 있다.
### 플랫폼 기반의 시스템 개발
- Plat + form = 구획된 땅 + 형성물
	- **다양한 형태로 발전시킬 수 있는 틀**
- 시스템의 기반이되는 H/W, S/W 플랫폼
	- **개발기간 단축**, **일정 수준의 품질 보장**(미리 만들어진 것들이 많은 덕분)
- 안드로이드: 모바일 디바이스 등의 개발을 위한 플랫폼
	- [[bootloader]]의 마지막 코드: 0x100에 LED가 있다. write 1한다. 
		- SSD의 OS를 읽어서 Ram에 올린다. [[DRAM]] 초기화 ...
		- bootloader를 잘 배우자..
- build 시에 linker가 만들어준다.
	- linking 단계에서 함수나 변수에 주소가 정해진다.
	- 프로그램 카운터

```c
(int*)0x100 = 1;
```

```c
(void(*)(int, int)) 0x100)(1, 2);
```

![[Pasted image 20241228153923.png]]
- 안드로이드는 OS가 아니다.
	- 리눅스 기반으로 작동되며 일부 OS 기능이 패치된 것이다.
	- 소프트웨어를 위해 만든 framework이다.
	- 상위 프레임워크는 굉장히 빨리 바뀐다.
		- 프레임워크는 제대로 알지 못해도 작업할 부분의 포인트를 파악하여 빠르게 기능을 제공하는 것이 목적.
- RTOS
	- 오픈소스로 풀지 않고, 자사 내에서 운영하는 경우가 많다.
	- 리눅스, [[FreeRTOS]](아마존) 중요

### 실행 이미지 생성 과정 x 실행
![[LIG Nex1_방산의_이해_OS#^group=Cm_dlxnGqU6UELRr6s4A_]]
- 컴파일을 좁게 봐야 한다.
	- Assembly 코드를 짜면 compile이 필요 없다.
- 변수의 주소, 함수의 주소는 PC의 경우 linker가 정해준다.
- linker 스크립트 파일 같은 것도 바꿔보고 하면 된다.
- PC에서 보면 가상 메모리이기 때문에 다 비슷하다.
	- 그렇다면 임베디드는?
		- linker한테 linker 스크립트를 통해 옵션을 줘서 ROM 몇 번지다. 크기 몇이다. 알려주어야 한다.
- 실행파일
	- OS가 실행 파일을 읽어서 메모리에 올려준다.
	- linker 주소 load 주소가 안 맞으면 실행 못하고 그럴 수 있다.
- loader & executer
	- 메모리에 띄웠지만...[[TODO]]
	- C가 동작하기위한 C runtime startup이라는 어셈블리어 코드가 있다.
	- 임베디드는 모두 환경이 달라서 만들어서 써야 한다. -> 칩 회사가 다 만들어서 넣어놓았다.
![[LIG Nex1_방산의_이해_OS#^group=QIu8Kfo9Vee2pwtokUKmg]]

### 프로세서, 메모리, 입출력장치
fetch -> decode -> execute
- 코드 메모리: ROM
- 데이터 메모리: DDR
### 명령어의 실행 사이클(122p)
- PC: program counter, 다음 실행할 명령의 주소를 저장한다.
	- 레지스터 뱅크에서 주소를 불러온다.
- bus를 통해 온다.
	- address bus: 주소 지정
		- 특정 장치를 지정하기 위한 버스 Read Only
	- data bus: 데이터 전송
		- 특정 데이터를 전송하기 위한 버스 R/W
	- control bus: 명령
![[LIG Nex1_방산의_이해_OS#^group=vsl54qcu9PMRP8SjdvEb0]]
- [[MUX]]
#### 디코더
- assembly를 디코드 한다.
- 명령어의 실행을 준비해주는 역할
	- ALU에 들어갈 값이 준비된다.
```
add     r0,r0,#1
opcode  operand
```
#### [[ALU]]
- ALU는 더하기 빼기 등의 간단한 논리 연산을 수행한다.

> [!info] [[Pipeline]]
> 분기예측, 이전의 결과를 저장
> 프로세서 구조를 잘 알아야 한다.
#### fetch cycle
- PC가 지시하는 명령을 명령 레지스터에 페치한다.
- 명령어를 해석하여 데이터에 대한 유효 주소(effective addrress)를 생성한다.
#### execute cycle
- 데이터를 페치하고 명령어를 실행한다.
#### interrupt cycle
- 인터럽트가 발생하면 위의 두 사이클을 마친 후 인터럽트에 대한 처리를 한다.
### 레지스터
- 실행 중간 결과나 적은 양의 자료를 임시로 저장하는 장치
	- [[Flip-flop]]으로 구현되어 있다.
- CPU 내부의 레지스터
	- 명령의 내용 또는 자료를 일시적으로 유지하는 등에 사용된다.
#### CPU 내부 레지스터의 종류
- 메모리 버퍼 레지스터(Memory Buffer Register, **MBR**)
	- 명령어: **동작을 지시하는 명령어 코드부**와 **데이터가 기억된 주소를 가리키는 주소부**로 되어있는 하나의 코드
	- 주기억 장치에 있는 명령어를 임시로 기억한다.
	- 모든 자료가 거치게 되는 자료 출입용 레지스터
- 메모리 어드레스 레지스터(Memory Address Register, **MAR**)
	- 주소 해독기에 의해 해독된 실행 대상의 데이터 주소를 기억하는 제어용 레지스터
- 명령어 레지스터(Instruction Register, **IR**)
	- MBR의 명령어 코드 **Op code(Operation code)** 를 기억한다.
	- 현재 수행 중인 명령어를 임시로 기억해두는 레지스터
- 프로그램 카운터(Program Counter, **PC**)
	- 다음에 실행될 명령어의 주소를 기억한다.
		- 주소: 기억 장치의 특정한 위치를 지정하기 위한 숫자, 이름 등의 값.
		- 바이트, 워드 등으로 지정된다.
- 명령어 해독기(Instruction Decoder)
	- 명령어 코드를 해독하여 필요한 실행 신호를 발생시킨다.
	- 해독기(**decoder**)는 [[부호화된 정보]]를 해독하는 장치로 명령어를 해독하기 위해 쓰이는 제어 장치의 일부이다.
	- 그 명령어가 어떤 일을 수행하기 위한 것인가를 알아내는 장치
- 주소 해독기(Address Decoder)
	- 주소를 해독하여 메모리 버퍼 레지스터로 전달한다.
- 인덱스 레지스터(Index Register, IR)
	- 명령어 실행 중 상태주소를 결정하는 레지스터
- 범용 레지스터(General Pupose Register, GPR)
	- 사용자가 프로그램에서 사용하는 범용 레지스터
- 베이스 레지스터(Base Regoster, BR)
	- 프로그램의 기준 주소를 가지고 있는 레지스터
![[Pasted image 20241230000812.png]]
출처: https://developer.arm.com/documentation/107656/0101/Registers/Registers-in-the-register-bank
#### 명령어 fetch cycle
![[LIG Nex1_방산의_이해_OS#^group=rCFMTx10Vl-LsSyt75Pbx]]
#### 명령어 실행 과정
### [[RISC|RISC]] vs [[CISC]]
- [[TODO]]
- (x86)CISC
- (ARM)RISC
#### **RISC**의 특징
- 저전력 프로세서를 만들고자 하는 움직임으로 RISC 설계
- 제어유닛과 디코더를 매우 효율적으로 개선했다.
- 명령어를 모두 4바이트로 통일 파이프라인에 굉장히 유리
- 리스크 성능이 떨어진다.
- 레지스트가 많이 필요하다.
	- 나중에 disassembly? 이런 것으로 뜯어보자.
![[LIG Nex1_방산의_이해_OS#^group=qPE-seJ0iJbQKxSLPuSEE]]

### I/O 장치
- 주소로 처리되어있다.
- RISC에서는 memory mapped I/O([[MMIO]])
	- I/O도 일반 메모리처럼 동작한다.
```c
cnt = 10;
while (cnt--) {
	a = 0;
	for (int i = 0; i < 1000; i++) ;
	a = 1;
	for (int i = 0; i < 1000; i++) ;
}
```
- 반복문이 아무것도 하고 있지 않아서 최적화를 시켜버린다.
- volatile memory(휘발성 메모리)
	- [[왜 volatile이라고 하는가]]?
	- 외부적인 요인에 있어서 휘발될 수 있으니, 바꾸지 마.
	- 최적화 하지 말라는 키워드
```c
// 0으로 최적화 시켜버린다.
while (*a != *a) {}
```
- Arm은 모드가 매우 많다.
	- User 모드, Kernel 모드 이외에도 많다.
- C가 CISC를 맞추기 위해 만들어진 언어이다.
- Arm은 C를 맞추기 위해 잘 만들어졌다.

### 소프트웨어 플랫폼
- 타이젠 
	- 모바일 디바이스, 차량시스템, 가전 등의 개발을 위한 소프트웨어 플랫폼
- AllJoin
	- RTOS 기반의 IoT 디바이스(Thin Client)용 플랫폼
	- 해당 플랫폼을 제공해서 칩을 사도록 한다..
	- 성공은 못했다.
	- [[BSP]]
	- C언어의 능력을 끌어올리기 위해 [[FreeRTOS]]의 코드를 뜯어보는 것도 좋다.

### 미들웨어
- 라이브러리와 같다.
### 운영체제
- 운영체제의 지상 과제
	- 제한된 하드웨어 리소스를 효율적으로 제공하는 것.
- RTOS
	- 이 또한 프로그램이기에 5-6% 정도 자원을 점유한다.
	- 자원을 16% 정도 효율적으로 사용할 수 있다.

## 어떤 절차로 소프트웨어를 개발할까?
### Build and Fix Model
- 공식적인 가이드라인이나 프로세스가 없는 개발 방식
	- 즉흥적으로 만든 후 필요 시 설계 수정, 유지보수 고민
	- 개발 후 문제가 있으면 수정해서 사용하고, 문제가 없으면 그냥 사용
- 단점
	- 관리 및 유지보수 어렵다: 사양 등의 산출 문서 없음
	- 여러 명이 나눠서 개발을 진행하기 어렵다.
	- 가독성 낮다.
	- 유지보수 힘들다.
### Warterfall Model
- 전통적인 SW 개발 절차
- 절차
	- 계획 - 요구사항 분석 - 설계 - 구현 - 시험 - 유지보수
- 각 단계가 끝날 때마다 산출물(결과) 확인 후 다음 단계 진행
	- 각 단계간의 상호작용이 없다. 직전 단계로의 피드백만 가능하다.
	- **단순하거나 해당 분야를 잘 아는 경우에 적합**
### V Model (Verification and Validation)
- 각 단계에 **검증**(테스팅)이 초점이 되어있다.
	- 중간 결과물, 프로젝트 시 산출물을 잘 작성하자.
![[Pasted image 20241227162055.png]]


> IoT Device, Mobile -> 데이터를 수집하고 통신해서 활용할 수 있으면 좋을 것 같다.
> 펌웨어로는 쉽지 않다.
> RTOS 또는 Linux를 사용 하는 수밖에 없다.
> 
> 오래 공부해야하는 분야.
> 참이슬은 오래 묵혀도 참이슬, 위스키는 오래 묵히면 레전드
> [[Process Architecture]], OS 등

> [!tip] 코딩 테스트 tip
> 구상 - 구현 - 디버깅 (중요도는 균등하다.)
> 애플리케이션 개발일 수록 많은 알고리즘에 대한 전형적인 문제가 출제
>   -> 삼성, LG(정확한 알고리즘을 가지고 구현하는 것)
>   
>   구상: 2개 이상의 구상을 통해 더 효율적인 방법을 선택하는 습관을 기르자.
>   구현: 내가 익숙한 방식으로 구현해야 한다. 디버깅에 영향을 미친다.
>   디버깅: 내가 자주하는 실수를 파악하고 극복하는 것이 중요하다.
> 
> 구현할 수 있는 방법으로 구상할 수 있어야 한다. (훈련이 필요하다.)
> 
> 안 풀리면 나갔다오고 이런 거 어차피 코테에 안 통한다.
> (4-5人)

---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
- [[PS]]