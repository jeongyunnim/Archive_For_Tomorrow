---
날짜: 2025-01-02
넘버: 
태그: 
출처: 
강사: 소영
aliases:
---
### 날짜:  2025-01-02 09:09

### 태그:

>[!메모]
>

### 원문
---
# 3.0 임베디드 소프트웨어 개발 C
### C언어란?
![[LIG Nex1_방산의_이해_OS#^group=tW1CQQOt]]
#### 반환값


### 10진수 -> 2진수
- 임베디드 개발자는 **진법 간의 변환이 빨라야 한다**.
- 금방금방 외워둬라.
- decimal
- octa
- hex
```
10 A 1010
11 B 1011
12 C 1100
13 D 1101
14 E 1110
15 F 1111
```

> [!tip] 코딩하기 좋은 폰트
> D2Coding

### x64, x86
- x86: 32비트 운영체제
- x64: 64비트 운영체제

### SDL 검사 -> off
- 입출력 함수를 쓸 수 밖에 없다.
- Security Development Lifecycle

### Visual Studio 2022 community
- 실행: ctl + F5

### 2의 보수[[TODO]]
```
-16
000010000
111101111 + 1
111110000
```
처음 나오는 1까지 그대로 쓰고 반전해도 된다.
```
-16
....00000
000010000
-10
00001010
......10
11110110
```
### 확장
```
*
&
[ ]
( )
```


### 변수는 누가 가지고 있는가?
- 변수에 저장 -> compiler가 알려준다고 해도 어디서 데이터에 대한 정보가 들어있는 것일까?
### 외부 장치
- OS에게 메모리를 할당 받는다.
	- Device Driver
	- 메모리 주소로 관리한다.
### 실수의 표현
- 지수부의 부호를 따로 표기하는 것이 아니라 float의 [[bias]](127)를 더해준다.
- 실수를 계산하는 코프로세서를 통해 계산한다.
	- 느리다.
### 변수
- 변수를 선언할 때 꼭 필요한 3가지 정보
	- 데이터의 타입(정수, 실수, 문자)
	- 메모리의 크기를 얼마로 할 것인가
	- 변수 이름
- 대입문은 expression이다.
```c
int func(void) {
	int a = 10;
	return a = 20;
}
/*
a = 10은 expression이다.
*/
```

> [!info] expression
> expression을 초기화할 수 있는 것은, expression이다.
> a = 10;

### l-value와 r-value
- `l-value = r-value`
	- 읽을 때는 r-value의 타입으로 읽고 쓸 때는 l-value의 타입으로 형변환 된다.
	- 맞춰주는 것이 best
### 변수의 선언
- 문제점?
```c
int n1 = 10, n2 =20;
int* p1, p2;
p1 = &n1;
p2 = &n2;
```
- p2는 int이다.

### 예약어
- 임베디드 개발자라면 struct와 union과 enum을 잘 쓸 수 있어야 한다.
```
-- 기억 클래스
auto
extern
register
static

-- 기타
const
sizeof
typedef
volatile

```

### limits.h
- 표준 정수타입의 범위를 결정하는 매크로가 지정되어 있다.
	- 음수 또한 연산이기 때문에 ()로 감싸주어 우선순위를 보장해준다.
```
#define SCHAR_MIN   (-128)
...
#define LLONG_MIN   (-9223372036854775807i64 - 1)
```
### stdint.h
- 고정된 크기의 정수형 타입을 정의한다.
	- 코드의 이식성, 명확성을 높이는 데 사용한다.

### 2진수 외우기[[TODO]]
$2^0 = 1$
$2^1 = 2$
$2^2 = 4$
$2^3 = 8$
$2^4 = 16$
$2^5 = 32$
$2^6 = 64$
$2^7 = 128$
$2^8 = 256$
$2^9 = 512$
$2^{10} = 1024$

### 문자열의 표현
![[Pasted image 20250102163945.png]]
- signed char에 128을 넣는 경우
	- -128
	- [[TODO]]
- 메모리에는 타입이 없다.
```c
int main(void) {

    unsigned char uch1 = -1;  // 0xFFFFFFFF(int) -> 0xFF(char) -> 255
    unsigned char uch2 = 128; // 0b 1000 0000 == 0x80
    signed char ch1 = -1;     // 0xFFFFFFFF(int) -> 0xFF(char) 부호비트를 가지고 확장한다.
    signed char ch2 = 128;    // 0xFFFFFF80(int) -> 0x80(char) -> 출력은 int로 하므로?

    printf("unsigned char(%%u) : %u %u\n", uch1, uch2);
    // 0xff -> 0xffffff80 -> 2의 보수 -> -128
    printf("signed char(%%d) : %d %d\n", ch1, ch2);
}
```
### 실수의 표현
- 유효 숫자
	- float: 7개 정도
	- double: 15개 정도
	- long double: 15개 이상
### sizeof 연산자
- 변수가 사용하는 메모리의 크기를 구할 수 있다.
	- `%zu`
	- sizeof 연산의 결과 타입인 `size_t`를 출력
- 컴파일 타임에 변수의 크기를 바이트 단위로 계산하는 연산
	- 컴파일 타임에 연산을 완료하기 때문에 오래 걸려도 실행 성능에는 아무런 문제가 없다.
- size_t: stddef.h에 정의된 부호 없는 정수형 타입
- 공용체, 구조체의 크기 계산에서는 내부 패딩도 포함한다.


### const
![[Pasted image 20250102172210.png]]
- const를 사용한 변수
- `const int * const value` 
- [[TODO]]
- `const int a`와 `int const a`는 같다.
```c
int const a = 10; // ROM에 작성된 메모리가 아니다. 따라서 쓰기 가능
int * b = &a;
*b = 20; // 가능


// *b 상수화 <- 이 레벨까지 많이 사용한다.
const int * b = &a;

// b(pointer) 상수화
int * const b = &a;

// 포인터도 값도 바꿀 수 없다.
const int * const b = &a;
```


### 실수할 여지가 많다.
```c
char name[20];
char *p = "ABC "; // 뼛 속까지 상수. 값 변경이 불가능하다.
p = name; //(0)
*p = 'X'; //(X)
p[0] = 'X'; //(X)
```


## 표준 입력
- 출력은 대개 4바이트로 출력한다.
	- int, short, char 모두 4바이트
- 입력은 엄격히 구분한다.
### scanf()
- 공백이나 탭을 처리하기 어렵다.
- 변수의 주소를 넘겨준다는 것이 중요하다.
### 임베디드에서의 입출력
- 표준 C에서 제공하는 함수를 쓰지 않는다.
### %f와 %lf는 다르다.
- 읽어올 데이터를 잘못 읽어올 수 있다.
### 문자열 입력
- white space를 구분자로 인식한다.
	- enter, tab, space 등
```c
#define _countof(array) (sizeof(array) / sizeof(array[0]))

char grade;
char name[20];

(void)scanf("%c", &grade); // 위험
scanf_s("%s", name, (unsigned int)_countof(name)) // 길이를 지정해줄 수 있어 더 안전하다.

```

### getchar() [[TODO]]
```c
while ((c = getchar()) != '\n' && c != EOF) {}
// input이 ABC\n이었다면
// ABC   ABC    ABC
// ^  ^
// r  w
```
### fgets()
```c
if (fgets(name, (int)sizeof(name), stdin) != NULL) {
	size_t len = strlen(name);
	if (len > 0 && name[len - 1] == '\n') {
		name[len - 1] = '\0';
	}
}
```

> [!복습]
> 문자 입출력
> 자료형(char, short, long, long long, int, float, double)
> 형변환 (signed char -> unsigned char)
> 
> 리터럴 -> 상수(값 변경 불가)
> 변수 -> 주소, 주소R/W 가능 시 - 값 변경

## 연산자

>[!important]
>연산자 우선순위
>하다보면 자연스럽게 이해될 것이다.

## 연산자 우선순위

![[Pasted image 20250103101007.png]]
### ++의 우선순위
- 후위 연산이 우선순위가 전위 연산보다 높다.
- 전위연산을 사용하자.
### `*`와 `&`, `(type)`
- 굉장히 많이 쓰게 될 것이다.
- [[주소는 4바이트]]?
- 선언된 타입의 포인터 변수 두 가지 정보를 가지고 있다.
	- 주소
	- 어떤 타입인가.
		- 얼마나 읽을 것인가?(4/8byte)
		- 어떻게 읽을 것인가(정수, 실수 등)
- void pointer
	- 타입이 정해지지 않은 포인터
	- 나중에 읽어올 때 타입을 결정하겠다는 의미
### 복합대입을 사용하자
- 유지보수 측면
> [!Q]
> 비트연산에서도 같은가?
### 연산 방향

- 단항 연산자, 대입 연산자는 오른쪽에서 왼쪽
```c
int a;
*&a = 20;
// a의 주소를 구해서 주소로 접근
int b[10][10];
b[1][3] = 10;
// b[1]을 구해서 [3]에 접근
// *(*(b + 1) + 3) = 10;

```
### 연산 시 주의 사항
- Overflow, Underflow에 주의해야 한다.
- 동일한 타입의 데이터끼리 연산을 수행해야 한다.
	- **필요 시 명시적 형변환을 사용한다.**
	- 암시적 형변환은 예상하지 못한 결과를 초래할 수 있다. 
- 레지스터 크기(4byte)가 있기 때문에 `char`, `short`의 연산도 정수로 계산한다.
	- [[정수의 승격]]
- %연산은 피연산자를 모두 양의 정수로 사용한다.
```c
int a = 10;
float b = 5.5;
int result_i = a + b;
float result_f = a + b;
// a + b는 float로 계산한다.
```
- 실수형의 한계
```c
int double_i = 9.999999999999999lf;// 10
int float_i = 9.999999f; // 10
```
- 자료형끼리의 연산
	- 정수 op 정수 -> 정수
	- 정수 op 실수 -> 실수
	- signed op unsigned -> unsigned int
- 정수의 승격(Integer Promotion Rules)
	- `int`, `unsigned int` 연산 시 `unsigned int`로 변환되어 연산된다.
```c
int a = -1;
unsigned int b = 1;

if (a < b) {
	printf("a is less than b\n");
} else {
	printf("a isn't less than b\n");
}
```
### 증감 연산자의 부작용
- 결과를 예측하기가 어렵다.
- 여러행에서 증감 연산을 사용하지 마라.
```C
int i = 5;
i = i++ + ++i;
printf("%d\n", i); // 13이지만 따져볼 필요 없다. 컴파일러마다 다를 것이다.
```
### 관계 연산자
- `&&`, `||`
	- 앞 뒤로 괄호로 묶는 것이 좋다.
### short-circuit
- 결과 예측이 되는 시점에서 멈춘다.
- `A && B` 
	- A가 참일 때만 B를 평가
- `A || B` 
	- A가 참이 아닐 때만 B를 평가
- Null Pointer Dereference 방지(Null Gaurd)에 활용 가능
	- `if (p != NULL && *ptr = 10)`
- 배열의 인덱스 유효성 검사
	- `if (i >= 0 && i < size && array[i] == 10)`

### 배열
- N차원이 되었든 메모리는 1차원으로 연속된 주소를 받아온다.
- `[x]`연산 type크기 * x 만큼 이동

| 1000 | 1004 | 1008 |
| ---- | ---- | ---- |
| 1012 | 1016 | 1020 |

```c
int main(void) {
    int a[5][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};

    printf("%d\n", a[0][0]);  // 1
    printf("%d\n", a[1][1]);  // 5
    printf("%d\n", a[0][4]);  // 3
    printf("%d\n", a[4][-5]); // 8
    printf("%d\n", a[5][-8]); // 8
    printf("%d\n", a[5][-8]); // 8
    // [ x ] 의 연산, 해당 주소에서 x만큼 이동
    // - 또한 적용된다.
}
```

### 표현별 어셈블리어 차이

![[Pasted image 20250103114659.png]]
![[Pasted image 20250103114915.png]]
![[Pasted image 20250103115104.png]]

## 비트 연산
- shift right `>>`는 부호비트로 채워진다.
```
#if 0

unsigned int setBit(unsigned int num, int bitPosition) {
    return (num | (1 << bitPosition));
}

unsigned int clearBit(unsigned int num, int bitPosition) {
    return (num & ~(1 << bitPosition));
}

unsigned int toggleBit(unsigned int num, int bitPosition) {
    return (num ^ (1 << bitPosition));
}

int main(void) {
    unsigned int num = 0b1010;
    int a, b, c;

    a = setBit(num, 2);
    b = clearBit(a, 1);
    c = toggleBit(b, 3);
    printf("Initial value: %X (binary:1010)\n", num);
    printf("After setting bit 2: %X (0b1110)\n", a, a);
    printf("After clearing bit 1: %X (0b1100)\n", b, b);
    printf("After toggling bit 3: %X (0b0100)\n", c, c);
    //int a = -10; // FF FF FF FF 1111 0110
    //printf("a << 1: %d %X\n", a << 1, a << 1); 
    //printf("a >> 2: %d %X\n", a >> 2, a >> 2);
}

#endif


#if 0

unsigned int setBit(unsigned int num, int start, int count) {
    return (num | (((1 << count) - 1) << (start)));
}

unsigned int clearBit(unsigned int num, int start, int count) {
    return (num & ~(((1 << count) - 1) << (start)));
}

unsigned int toggleBit(unsigned int num, int start, int count) {
    return (num ^ (((1 << count) - 1) << (start)));
}

int main(void) {
    unsigned int num = 0b10101010;
    int a, b, c;

    //printf("%X\n", setBit(0, 3, 1));
    a = setBit(num, 2, 3); // BE 1011 1110
    b = clearBit(a, 4, 2); // 8E 1000 1110
    c = toggleBit(b, 1, 5);// B0 1011 0000
    printf("After setting bit 2: %X (10111110)\n", a, a);
    printf("After clearing bit 1: %X (10001110)\n", b, b);
    printf("After toggling bit 3: %X (10110000)\n", c, c);
}

#endif

#if 1

static unsigned int isBitSet(unsigned int num, int bitPosition) {
    if (0 <= bitPosition && bitPosition < 32)
        return num & (1 << bitPosition);
}

int main(void) {
    int target;
    int check;
    printf("Enter a number: ");
    scanf("%d", &target);
    printf("Enter bit position to check(0-31): ");
    scanf("%d", &check);
    printf("Bit %d of number %d is %d\n", check, target, isBitSet(target, check));
}

#endif
```
## 데이터 타입
- 32/64
```c
char x = 127;
char y = x + 1;

printf("%d, %d, %d", x, x + 1, y);
x = -128;
y = x - 1;
printf("%d, %d, %d", x, x - 1, y);
```
![[Excalidraw/LIG Nex1_embedded_C.md#^group=N1xrCHEJ0AgNWVTj3VLYa]]

### `/`와 `%`활용
- 4자리 수를 받아 1000, 100, 10, 1 자리값을 출력하라.
```c
#if 1

int main(void) {
    int a = 12;
#if 1
    int res1 = a % 3 == 0 | a % 5 == 0; // |, || 
    int res2 = a >= 4 & a <= 8; // &, && 비트연산과 논리연산의 차이 
#else
    int res1 = (a % 3 == 0) | (a % 5 == 0);
    int res2 = (a >= 4) & (a <= 8);
# endif
    printf("%d\n%d", res1, res2);
    return 0;
}

#endif
``` 

- 0.0은 false
### `~`와 `!`

```C
~(10 < 20) // FFFFFFFE
~~(10 < 20) // FFFFFFFE
```
### 복합 대입 연산자
```c
a %= b -= 1;
// <--------연산 방향
```
### 자동형변환
- 크기가 다른 자료형끼리 연산 처리가 될 때 크기가 작은 자료형이 크기가 큰 자료형으로 바뀌어져 계산 처리가 이루어지는 것.
- step1: 연산 대상체가 int 자료형보다 작은 크기를 갖는 경우
	- int 크기로 변환되어 연산된다. (signed int);
- step2: 같은 크기의 자료형인 경우 signed -> unsigned
### Integer Promotion 정수의 승격
![[Pasted image 20250103160309.png]]
- 상위비트는 0으로 채워진다.
- signed char에서 unsigned int, int로 변환 시, 모자라는 상위비트는 1로 채워진다.
	- [[TODO]]: 확실하게 합시다.
```c
unsigned char a = 0xf0;
char b = 0xf0; 
unsigned char c = 0x0f;
char d = 0x0f;
//F0 FFFFFFF0 F F
```

```
0000 0000 | 0000 0000 | 0000 0000 | 1111 0000 
1111 1111 | 1111 1111 | 1111 1111 | 1111 0000 
0000 0000 | 0000 0000 | 0000 0000 | 0000 1111
0000 0000 | 0000 0000 | 0000 0000 | 0000 1111 
```

```c
a == ~c
a == ~d
b == ~c
b == ~d
```
- 확실히 하자...
![[Pasted image 20250103161658.png]]
### [[TODO]]
```c
int main(void) {
    unsigned int a = 1; // 0x00000001
    char b = -1; //0xFF

    printf("%d, %u\n", a < b, b); // 0x000000001 0xFFFFFFFF
    // printf("%d, %u\n", a < (unsigned int)b, b); // 0x000000001 0xFFFFFFFF
    return 0;
}
```

### printf()의 **Conversion specifiers** 중요
- 4byte
	- d, c, p, zu, u
- 8byte
	- f, lf, llu
- **scanf**와 다르다.
	- c는 1바이트를 읽어온다.
```C
int main(void) {
    unsigned int a = -1;
    unsigned long long b = (unsigned long long) a + 1;

    printf("%llu\n", a + 1); // 건네준 건 4바이트, 읽으려는 건 8바이트: 쓰레기 값도 같이 읽기 때문에 이상한 값이 나오는 문제가 발생한다.
    printf("%llu\n", b);
}
```

## 배열
- 포인터: c언어에서 할 수 없는 것들을 우회적으로 할 수 있게 해주는 녀석
	- 가장 많이 하게 되는 것 -> 함수의 호출
	- 배열은 함수의 argument로 사용할 수 없다.
	- 함수 또한 argument로 사용할 수 없다.
- 포인터로 주고받고 있기 때문에 가능하다.
	- 함수와 배열의 이름은 주소를 의미한다.
	- **포인터가 무엇을(TYPE) 가리키고 있는지가 중요**하다.


---
### 생각(파생된 질문/생각)

### 출처

### 연결 문서 (연결 이유)
