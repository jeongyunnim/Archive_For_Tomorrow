---
날짜: 2025-01-02
넘버: 
태그: 
출처: 
aliases:
---
### 날짜:  2025-01-02 09:09

### 태그:

>[!메모]
>

### 원문
---
# 3.0 임베디드 소프트웨어 개발 C
### C언어란?
![[Excalidraw/LIG Nex1.md#^group=tW1CQQOt]]
#### 반환값


### 10진수 -> 2진수
- 임베디드 개발자는 **진법 간의 변환이 빨라야 한다**.
- 금방금방 외워둬라.
- decimal
- octa
- hex
```
10 A 1010
11 B 1011
12 C 1100
13 D 1101
14 E 1110
15 F 1111
```

> [!tip] 코딩하기 좋은 폰트
> D2Coding

### x64, x86
- x86: 32비트 운영체제
- x64: 64비트 운영체제

### SDL 검사 -> off
- 입출력 함수를 쓸 수 밖에 없다.
- Security Development Lifecycle

### Visual Studio 2022 community
- 실행: ctl + F5

### 2의 보수[[TODO]]
```
-16
000010000
111101111 + 1
111110000
```
처음 나오는 1까지 그대로 쓰고 반전해도 된다.
```
-16
....00000
000010000
-10
00001010
......10
11110110
```
### 확장
```
*
&
[ ]
( )
```


### 변수는 누가 가지고 있는가?
- 변수에 저장 -> compiler가 알려준다고 해도 어디서 데이터에 대한 정보가 들어있는 것일까?
### 외부 장치
- OS에게 메모리를 할당 받는다.
	- Device Driver
	- 메모리 주소로 관리한다.
### 실수의 표현
- 지수부의 부호를 따로 표기하는 것이 아니라 float의 [[bias]](127)를 더해준다.
- 실수를 계산하는 코프로세서를 통해 계산한다.
	- 느리다.
### 변수
- 변수를 선언할 때 꼭 필요한 3가지 정보
	- 데이터의 타입(정수, 실수, 문자)
	- 메모리의 크기를 얼마로 할 것인가
	- 변수 이름
- 대입문은 expression이다.
```c
int func(void) {
	int a = 10;
	return a = 20;
}
/*
a = 10은 expression이다.
*/
```

> [!info] expression
> expression을 초기화할 수 있는 것은, expression이다.
> a = 10;

### l-value와 r-value
- `l-value = r-value`
	- 읽을 때는 r-value의 타입으로 읽고 쓸 때는 l-value의 타입으로 형변환 된다.
	- 맞춰주는 것이 best
### 변수의 선언
- 문제점?
```c
int n1 = 10, n2 =20;
int* p1, p2;
p1 = &n1;
p2 = &n2;
```
- p2는 int이다.

### 예약어
- 임베디드 개발자라면 struct와 union과 enum을 잘 쓸 수 있어야 한다.
```
-- 기억 클래스
auto
extern
register
static

-- 기타
const
sizeof
typedef
volatile

```

### limits.h
- 표준 정수타입의 범위를 결정하는 매크로가 지정되어 있다.
	- 음수 또한 연산이기 때문에 ()로 감싸주어 우선순위를 보장해준다.
```
#define SCHAR_MIN   (-128)
...
#define LLONG_MIN   (-9223372036854775807i64 - 1)
```
### stdint.h
- 고정된 크기의 정수형 타입을 정의한다.
	- 코드의 이식성, 명확성을 높이는 데 사용한다.

### 2진수 외우기[[TODO]]
$2^0 = 1$
$2^1 = 2$
$2^2 = 4$
$2^3 = 8$
$2^4 = 16$
$2^5 = 32$
$2^6 = 64$
$2^7 = 128$
$2^8 = 256$
$2^9 = 512$
$2^{10} = 1024$

### 문자열의 표현
![[Pasted image 20250102163945.png]]
- signed char에 128을 넣는 경우
	- -128
	- [[TODO]]
- 메모리에는 타입이 없다.
```c
int main(void) {

    unsigned char uch1 = -1;  // 0xFFFFFFFF(int) -> 0xFF(char) -> 255
    unsigned char uch2 = 128; // 0b 1000 0000 == 0x80
    signed char ch1 = -1;     // 0xFFFFFFFF(int) -> 0xFF(char) 부호비트를 가지고 확장한다.
    signed char ch2 = 128;    // 0xFFFFFF80(int) -> 0x80(char) -> 출력은 int로 하므로?

    printf("unsigned char(%%u) : %u %u\n", uch1, uch2);
    // 0xff -> 0xffffff80 -> 2의 보수 -> -128
    printf("signed char(%%d) : %d %d\n", ch1, ch2);
}
```
### 실수의 표현
- 유효 숫자
	- float: 7개 정도
	- double: 15개 정도
	- long double: 15개 이상
### sizeof 연산자
- 변수가 사용하는 메모리의 크기를 구할 수 있다.
	- `%zu`
	- sizeof 연산의 결과 타입인 `size_t`를 출력
- 컴파일 타임에 변수의 크기를 바이트 단위로 계산하는 연산
	- 컴파일 타임에 연산을 완료하기 때문에 오래 걸려도 실행 성능에는 아무런 문제가 없다.
- size_t: stddef.h에 정의된 부호 없는 정수형 타입
- 공용체, 구조체의 크기 계산에서는 내부 패딩도 포함한다.


### const
![[Pasted image 20250102172210.png]]
- const를 사용한 변수
- `const int * const value` 
- [[TODO]]

## 표준 입력
- 출력은 대개 4바이트로 출력한다.
	- int, short, char 모두 4바이트
- 입력은 엄격히 구분한다.
### f와 lf는 다르다.
- 읽어올 데이터를 잘못 읽어올 수 있다.
### 문자열 입력
- white space를 구분자로 인식한다.
	- enter, tab, space 등
```c
#define _countof(array) (sizeof(array) / sizeof(array[0]))

char grade;
char name[20];

(void)scanf("%c", &grade); // 위험
scanf_s("%s", name, (unsigned int)_countof(name)) // 길이를 지정해줄 수 있어 더 안전하다.

```


---
### 생각(파생된 질문/생각)

### 출처

### 연결 문서 (연결 이유)
