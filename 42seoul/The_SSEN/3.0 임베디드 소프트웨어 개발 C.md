---
날짜: 2025-01-02
넘버: 
태그: 프로그래밍/임베디드
출처: 
강사: 윤소영
aliases:
---
### 날짜:  2025-01-02 09:09

### 태그: #프로그래밍/임베디드 

>[!메모]
>

### 원문
---
# 3.0 임베디드 소프트웨어 개발 C
[[3.1 변수]] 
[[3.2 표준 입력]]
[[3.3 연산자]]
[[3.4 자동 형변환]]
### C언어란?
![[LIG Nex1_방산의_이해_OS#^group=tW1CQQOt]]

### 10진수 -> 2진수
- 임베디드 개발자는 **진법 간의 변환이 빨라야 한다**.
- decimal
- octa
- hex
```
10 A 1010
11 B 1011
12 C 1100
13 D 1101
14 E 1110
15 F 1111
```

> [!tip] 코딩하기 좋은 폰트
> D2Coding

### x64, x86
- x86: 32비트 운영체제
- x64: 64비트 운영체제

### SDL 검사 -> off
- 입출력 함수를 쓸 수 밖에 없다.
- Security Development Lifecycle

### Visual Studio 2022 community
- 실행: ctl + F5
### printf()의 **Conversion specifiers** 중요
- 4byte
	- d, c, p, zu, u
- 8byte
	- f, lf, llu
- **scanf**와 다르다.
	- c는 1바이트를 읽어온다.
```C
int main(void) {
    unsigned int a = -1;
    unsigned long long b = (unsigned long long) a + 1;

    printf("%llu\n", a + 1); // 건네준 건 4바이트, 읽으려는 건 8바이트: 쓰레기 값도 같이 읽기 때문에 이상한 값이 나오는 문제가 발생한다.
    printf("%llu\n", b);
}
```

## 배열
- 포인터: c언어에서 할 수 없는 것들을 우회적으로 할 수 있게 해주는 녀석
	- 가장 많이 하게 되는 것 -> 함수의 호출
	- 배열은 함수의 argument로 사용할 수 없다.
	- 함수 또한 argument로 사용할 수 없다.
- 포인터로 주고받고 있기 때문에 가능하다.
	- 함수와 배열의 이름은 주소를 의미한다.
	- **포인터가 무엇을(TYPE) 가리키고 있는지가 중요**하다.
- [[TODO]]
	- 실제로 어떤 값을 저장하고 있는가? 
```c
int *p1[3]; // P1은 배열 -> 연산자 우선 순위가 []가 *보다 높다.
int (*p2)[3]; // p2는 포인터
int (*p3[2])[4]; // P3은 배열
```
- 요소의 수가 중요하다.

![[Excalidraw/LIG Nex1_embedded_C.md#^group=BdEZRTz1Mdb5X9WYeDGmu]]

## 변수
- modifier
	- `*`: 주소화
	- `[]`: 집합화, 배열
	- `()`: 함수화
	- 만드는 방법과 사용하는 방법이 일치한다.
- 우선 순위
	- {`()`, `[]`} -> `*`
	- 같이 붙일 수는 없다.
- 각 type의 의미
```c
// 포인터가 가리키는 것에 대한 타입
int *p;
// 배열의 요소의 타입
int p[3];
// 함수의 반환형에 대한 타입
int p();
```

### 문제
```c
int *(*a[5]) (int *);
```

- [[TODO]]
	- `int*`는 뭔데
```
1. a[5]: a는 배열이다.
2. *a[5]: a는 포인터 배열이다.
3. int* (*a[5])(int*):int를 반환하고 int* 형 parameter를 가지는 함수
-> a는 함수 포인터 배열이다.
```

```c
int (*p)[3];
```
: 배열 포인터

```c
int **p;
```
: 2중 포인터

### 주소처리 연산자 `[]`
```c
a[1] == *(a + 1);
```
- pointer의 덧셈

---
### 생각(파생된 질문/생각)

### 출처

### 연결 문서 (연결 이유)
