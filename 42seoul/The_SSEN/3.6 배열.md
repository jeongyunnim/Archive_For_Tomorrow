---
날짜: 2025-01-06
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 윤소영
교재: 
aliases:
---
### 날짜:  2025-01-06 17:32

### 태그: #프로그래밍/임베디드

>[!메모]
>

### 원문
---
# 3.6 배열
## 배열
- 배열이란
	- 동일한 타입의 여러 개의 메모리를 연속적으로 할당하는 것
- 포인터: c언어에서 할 수 없는 것들을 우회적으로 할 수 있게 해주는 녀석
	- 가장 많이 하게 되는 것 -> 함수의 호출
	- 배열은 함수의 argument로 사용할 수 없다.
	- 함수 또한 argument로 사용할 수 없다.
- 포인터로 주고받고 있기 때문에 가능하다.
	- 함수와 배열의 이름은 주소를 의미한다.
	- **포인터가 무엇을(TYPE) 가리키고 있는지가 중요**하다.
	- 실제로 어떤 값을 저장하고 있는가? 
```c
int *p1[3]; // P1은 배열 -> 연산자 우선 순위가 []가 *보다 높다.
int (*p2)[3]; // p2는 포인터
int (*p3[2])[4]; // P3은 배열
```
- 요소의 수가 중요하다.

![[Excalidraw/LIG Nex1_embedded_C.md#^group=BdEZRTz1Mdb5X9WYeDGmu]]

### 배열을 0으로 초기화 하는 방법
```c
int arr[100] = {0};
```
- 1로 하면 1로 초기화 되는가?
	- 1, 0, 0, 0 ... 으로 초기화 된다. 왜??

> [!tip] [[ISO/IEC 9899]] 
> If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration.
> 
> 출처: ISO/IEC 9899 6.7.9 Initialization 
> https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf
### 배열의 이름은 주소다.
- 배열의 이름은 컴파일러가 지정해준 주소를 가리키고 있다.
	- **포인터 상수**이다.
	- 덧셈 또는 뺄셈이 가능하다.
	- 참조연산(`*`)이 가능하다.
- 포인터의 덧셈
	- 자료형의 크기 만큼 증가한다.
	- `arr[10] == arr + 10`;
### 상수는 주소가 있는가?
```c
&100; // error
&arr; // OK
```
- **포인터 상수라면서 주소 연산이 왜 되느냐?**
	- 배열의 이름에 `&`을 붙이면 주소를 가져오라는 것이 아니라, 가리키는 타입이 무엇인지를 가리킨다.
	- 따라서 `배열 전체`를 의미한다.
	- `int arr[5];`의 경우
		- arr: `arr[0]`을 의미
		- &arr: `int arr[5]` 배열 전체를 의미
- 크기 정보
	- `&`를 붙였을 때는 포인터로써의 기능으로 보기 때문에 주소의 크기 4바이트가 나온다.
```c
printf("arr: %p, &arr %p", arr, &arr) // arr: 004FF9FC, &arr 004FF9FC
printf("%d, %d", sizeof(arr), sizeof(&arr)); // 20, 4
```
- 2가지 상황에서는 배열로써 역할한다.
```c
sizeof(arr); // 배열의 전체 바이트 반환
sizeof(&arr); // 포인터 크기 (4)
```
- 나머지 상황에서는 pointer의 성격이 강하다.
```c
arr;
*arr; // == arr[0]
arr[i];
arr + i;
```
### 놀랍다.
```c
int arr[4];

printf("%p %p\n", ary, &ary);  // ary => 배열의 이름 (포인터 상수)
printf("%p %p\n", ary + 1, &ary + 1);
```
- output
	- `&ary + 1`은 &ary가 전체 배열을 가리키고 있기 때문에 ary 전체 배열의 크기만큼 주소값이 증가했다.
```
00F5F710 00F5F710
00F5F714 00F5F724
```

### 포인터
- 주소를 말한다.
- 포인터 변수
	- 주소를 저장하는 변수
- **무엇을 가리키는지 알려주어야 한다.**
	- 사용할 때 어떻게 읽을지 알아야 하기 때문이다.
```c
int (*a)[3];
// a가 0x1000이라면 a + 1은 0x100C이다.

int arr[5];
//arr를 가리키는 포인터 변수를 만들고 싶다면, int (*arr_p)[5]
```

### N차원 배열의 요소
```c
int arr[3][5];
```
- 일반적으로 arr의 요소는 3개이고, 각 요소가 5개 씩 갖고 있다.
```c
int arr[3][5];
// arr의 주소가 0x1000 이라면 arr + 1은 0x1016 이다.
```
- `arr`: 2차원 배열의 이름
- `arr[i]`: 1차원 배열의 이름
	- `int *ap = arr[0]`;

```c
int **a[3][4];
//ㅁㅁㅁㅁ
//ㅁㅁㅁㅁ
//ㅁㅁㅁㅁ -> 각 타입은 (int **)
```

![[Excalidraw/LIG Nex1_embedded_C.md#^group=LjhZyOIzR-wazKQIX5X3i]]
```c
int (*a[4])[3];
// ㅁㅁㅁㅁ -> 각 타입은 (int * [3]);
// 각 요소는 int x1[3][3], x2[2][3];
```



---
### 출처
- LIG Nex1 The SSEN Embedded SW School

