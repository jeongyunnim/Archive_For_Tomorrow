---
날짜: "2025-02-27"
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 홍영기
aliases:
---
### 날짜:  2025-02-27 12:39

### 태그: #프로그래밍/임베디드

>[!메모]
> 

### 원문
---
# NVIC & EXTI
- 인터럽트
	- PWM과 NVIC 연동
- NVIC
	- Nested vectored Inturrupt Controller
	- 인터럽트 제어기
- EXTI
	- GPIO 핀을 통해 들어오는 인터럽트
![[Excalidraw/LIG Nex1 임베디드.md#^group=g8mPQ6li]]
- 외부 인터럽트 핸들러 프로토타입 예시
	- key_isr(void)
	- interrupt service routine
- 내부 인터럽트 핸들러 프로토타입 예시
	- timer_isr(void)
- USB가 꽂혔을 때도 인터럽트가 발생한다.
	- usb_isr(void)
- 특징
	- 이벤트는 언제 발생할지 모른다.
	- CPU가 임의의 동작을 모니터링을 직접하지 않아도 된다.
	- 간편(단순)하고, 즉각적이다.
	- 노말 루틴을 중지하고 인터럽트 루틴을 실행한다.
- 과도한 대기 시간 지연 위험, 변경 사항을 모두 놓칠 가능성, 필요한 처리 시간 및 전력 소비량 증가
	- 폴링 방식: 너무 길면 반응이 느려지고, 감지 자체를 못할 수 있다.
	- 과도한 정보 수집으로 인한 전력 소비량 증가
```c
while (1)
{
	// routine
	HAL_Delay(1000);
}
```
### 인터럽트
- ISR, 인터럽트 핸들러를 비동기적으로 수행한다.
- 인터럽트를 처리하면 이전 상태를 복원하고 수행을 재개한다.
### 우선순위
- 인터럽트 핸들러를 수행 중이더라도, 더 높은 우선 순위의 인터럽트가 트리거되면 더 높은 우선순위의 인터럽트가 서비스 된다.

### 인터럽트 초기화
- 모든 인터럽트 활성화
### 인터럽트 마스크 레지스터
- 마스킹: 관심이 없는 인터럽트를 무시할 수 있다.
	- NVIC 측 마스킹
	- CPU 측 마스킹
- NVIC
	- CPU와 관계를 가진다.
	- 각 장치와 관계를 가진다.
	- 인터럽트를 수집해준다.
	- 중개해준다.
- 인터럽트 펜드
	- 인터럽트가 마스킹되면 컨트롤러는 CPU에 대한 인터럽트 요청을 생성하지 않지만, 펜딩 레지스터에서 해당 상태를 계속 볼 수 있다.
### 실습: 버튼키 인터럽트
- 버튼이 눌렸을 때 자동으로 실행 
## NVIC
:Nested Vectored Interrupt Controller
- Cortex-M 프로세서의 일부이며 코어와 밀접하게 연결되어있다.
- 16개의 내부 인터럽트 + 240개의 외부 인터럽트
- 레벨 및 **펄스** 인터럽트 소스를 모두 지원한다.
	- 실제로는 펄스 인터럽트만 지원한다.
- NVIC는 인터럽트의 테일 체인을 지원한다.
### 펄스 트리거 인터럽트
- rising edge 또는 falling edge를 감지하면 인터럽트가 발생한다.
- pulse trigger == edge trigger
- 레벨 트리거
	- 특정 레벨에 도달하면 인터럽트가 발생한다. 해당 레벨이 유지 되는 동안 인터럽트가 유지된다.
	- Cortex에서는 레벨트리거 방식의 인터럽트를 직접 지원하지 않는다.
- 대기 중인 인터럽트 상태로 저장한다.
- 인터럽트를 받으면 이를 대기(pending) 인터럽트 상태로 저장한다.
	- 인터럽트 핸들러가 호출되면 대기 중인 인터럽트 상태가 자동으로 지워진다.
	- NIVIC_ISPR
- IRQs
	- Interrupt ReQuest source
- NMI
	- None Maskable Interrupt
	- 마스크할 수 없는 인터럽트
	- 시스템 운영에 중대한 인터럽트들이 있다.
### NVIC 레지스터
- 소프트웨어가 액세스할 수 있는 메모리 매핑 레지스터가 있다.
- 32비트 폭을 가진다.
	- 각 비트는 하나의 인터럽트 입력을 나타내며, 인터럽트를 제어하는데 사용한다.
- NVIC_ISER / NVIC_ICER
	- 인터럽트 활성화, 비활성화
	- set / clear interrupt register
- NVIC_ISPR / NVIC_ICPR
	- 인터럽트 처리
	- set / clear pending register
- [ ] 그러면 같은 인터럽트에 대해 인터럽트가 쌓이나?
## 예외처리 핸들러
### 예외처리 핸들러의 진입
```
1. 현재 명령어 종료
2. 컨택스트를 현재 스택에 push
3. 핸들러/특권 모드로 전환, MSP 사용
4. 예외 핸들러 주소로 PC 로드
5. EXC_RETURN 코드로 LR 로드
6. 예외 번호로 IPSR 로드
7. 예외 핸들러 코드 실행 시작
```

![[Excalidraw/LIG Nex1 임베디드.md#^group=k4rz3_0IUJcZUgoV9P7aF]]
```c
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)); // 쓰기 동작으로 끝난다.
  }
}

__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    __DSB();
    __ISB();
  }
}
```
- NVIC_ISER0, NVIC_ICER0의 값이 0x40으로 세팅 되어있다.
	- 마스킹 하면 0x0으로 리셋된다.
```c
HAL_NVIC_DisableIRQ(6); // using NVIC->ICER
``` 
### 버튼의 EXTI 번호를 어떻게 확인하는가
- 핀 번호를 본다.
	- EXTI 번호를 확인한다.
	- EXTI0이라는 것을 확인
- 데이터 시트를 본다. (12장 Interrupts and events)
![[Excalidraw/LIG Nex1 임베디드.md#^group=yYevV97e6Sa0DorXgIvXy]]
- 인터럽트 번호가 6번인 이유
![[Excalidraw/LIG Nex1 임베디드.md#^group=wQLIsFS0]]

```c hl:3
/*Configure GPIO pin : B1_Pin */
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
```
- Mode를 변경하는 법
	- 일단 open declaration
	- `GPIO_MODE_IT_RISING_FALLING` 이라는 매크로를 발견
- [ ] EXTI0번의 핸들러를 하나만 전달하는데 CPU는 PA6을 어떻게 찾아가는가?
### 인터럽트 상태
- 인터럽트가 왔을 때 NVIC은 CPU에게 처리해달라고 인터럽트를 준다.
```c hl:6
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin); // 인터럽트 상태 클리어
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}
```
- 따라가보면 `EXTI->PR = __EXTI_LINE__`을 볼 수 있다.
	- 확인 했으면, 데이터시트를 좀 읽어라.
```
#define __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))
```
![[Pasted image 20250227172332.png]]
- 버튼 누르면 신호가 들어가고 exti에서 비트가 1로 바뀐다.
- 의도적으로 바꾸지 않는 한 1이 유지가 된다.
- **지우는 건 어떻게 지우는가**
	- 상태 레지스터는 역사적으로 덮어쓰기 방식으로 구현했다.
	- 원자적, atomic하다는 장점이 있다.
```c
*rEXTI_PR = *rEXTI_PR & ~(1 << 0) // bad
*rEXTI_PR = (1 << 0); // good -> atomic 하다
```
### 우선순위 설정
- 동적 우선순위를 통해 우선 순위를 변경할 수도 있다.
```c
  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI0_IRQn);
```
- NVIC의 내용을 보려면 ARM 프로세서 데이터 시트를 봐야 한다.
	- [ ] 0번은 왜 안보이는가?
![[Pasted image 20250227173754.png]]



---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
