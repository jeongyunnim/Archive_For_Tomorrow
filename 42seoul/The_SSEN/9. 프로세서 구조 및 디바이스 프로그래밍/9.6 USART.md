---
날짜: "2025-02-28"
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 홍영기
aliases:
---
### 날짜:  2025-02-28 14:37

### 태그: #프로그래밍/임베디드

>[!메모]
> 

### 원문
---
# 9.6 USART
- 시리얼 통신 장치
### 실습: UART를 이용하여 출력하기

```c
int __io_putchar(int ch)
{
 if ( ch == '\n' )
	 HAL_UART_Transmit(&huart1, (uint8_t*)&"\r", 1, HAL_MAX_DELAY);
 HAL_UART_Transmit(&huart1, (uint8_t*)&ch, 1, HAL_MAX_DELAY);
 return ch;
}
```

```
\n: 줄 바꿈 + 맨 앞으로(\r)
\r: 캐리지 리턴
```
- [ ] weak함수는 윈도우나 맥에서도 제공하나?
### HAL_UART_Transmit()
- STM32F103CBT6 칩: 디버깅을 위한 칩
	- Cortex-M3
![[Pasted image 20250228153637.png]]
- 컴퓨터와 USB로 연결상태를 유지하게 해주는 기능을 해주는 칩
![[Excalidraw/LIG Nex1 임베디드.md#^group=1uc5zVp9etbfJV8eOK5Ei]]
![[Pasted image 20250228155114.png]]
- instance는 레지스터 이다.
	- UART_HandleTypeDef
	- `*instance`는 SFR이다.
	- 레지스터를 묶어서 구조체로 접근한다.
```c
typedef struct __UART_HandleTypeDef
{
  USART_TypeDef                 *Instance; 
...

typedef struct
{
  __IO uint32_t SR;         /*!< USART Status register,                   Address offset: 0x00 */
  __IO uint32_t DR;         /*!< USART Data register,                     Address offset: 0x04 */
  __IO uint32_t BRR;        /*!< USART Baud rate register,                Address offset: 0x08 */
  __IO uint32_t CR1;        /*!< USART Control register 1,                Address offset: 0x0C */
  __IO uint32_t CR2;        /*!< USART Control register 2,                Address offset: 0x10 */
  __IO uint32_t CR3;        /*!< USART Control register 3,                Address offset: 0x14 */
  __IO uint32_t GTPR;       /*!< USART Guard time and prescaler register, Address offset: 0x18 */
} USART_TypeDef;
```
- Init 함수를 하나씩 
![[Pasted image 20250228155534.png]]
### CR1: Contol Register
- **장치에는 Control 레지스터가 들어있다.**
	- Control 레지스터는 가장 중요한 레지스터이기 때문에 싹 봐주는 것이 좋다.
		- 한 번이라도 읽은 단어들은 남아있으니까..
	- 장치를 세팅하기 위해 보통 1을 많이 사용하지만, 0이 기본 값인 경우가 많다.
		- 그래서 일단 켜진 것들을 살펴보는 것이다.
![[Excalidraw/LIG Nex1 임베디드.md#^group=4PoQedrF]]
- UE
	- USART enable
### BRR
- 보율 레지스터
	- [[baud rate]]
	- 통신속도
- mantissa & fraction
	- 
![[Pasted image 20250228162533.png]]
![[Pasted image 20250228163148.png]]
- 0xD0 == 0b 1101 0000 == 208
	- Mantissa: 13(0xD)
	- Fraction: 0
![[Pasted image 20250228164611.png]]
- OVER8은 0으로 세팅 되어 있었기 때문에(CR1) Oversampling by 16 테이블을 참조한다.
![[Pasted image 20250228163952.png]]

- 메모리맵을 활용해서 UART1이 어느 버스를 쓰는지 확인
	- APB2
![[Pasted image 20250228164150.png]]
- $f_{PCLK}$가 24인 경우는 표에 나타나있지 않기 때문에 12로 맞춘다.
	- 새로 설정된 BBR값: 0x68
	- mantisa: 0x6
	- fraction: 0x8
	- 6.5

### 세팅을 올바르게 하는 방법을 알아내면 되는 것이다.
### SR
- 0xC
![[Pasted image 20250228165302.png]]
- TXE
	- Transmit data register empty
- TC
	- Transmission complete
![[Excalidraw/LIG Nex1 임베디드.md#^group=bX2nuvUlDEDqK5HpOkRQG]]
![[Pasted image 20250228170301.png]]
![[Excalidraw/LIG Nex1 임베디드.md#^group=vlWZCi-Bz6EpjgqRvPpQT]]
- 7번을 보면, 왜 DR레지스터가 비워지는지 알 수 있다.
	- TXE가 무슨짓을 하고 있는지 보려면 다시 함수로 들어가자.
	- TXE가 1이 될 때까지 기다렸다가 써야 한다.
### 검증의 단계
- 요놈 보세요.
![[Pasted image 20250228170658.png]]
- polling 방식을 통해서 쓰고 있다.
	- 펌웨어는 대부분 이런 방식으로 구현을 해놓고 있다.
		- 관행적, legacy
	- [ ] 이러한 문제를 DMA방식을 적용하면 해결할 수 있지 않을까?
![[Pasted image 20250228172431.png]]
### USART
- [ ] 전이중: pold flexer?
- Synchronous / Asynchronous
- 송신기는 CPU에서 병렬 데이터(ASCII를 병렬로 받는다.)
- 수신기는 채널 수신기 직렬 데이터 입력에서 직렬 데이터를 수신하고 
	- MCU 안에 들어있다.
### UART 
- 장치 간 저속 데이터를 전송하는 데 사용된다.
- [ ] USART와 속도 차이가 큰가?

#### 오버샘플링
![[Excalidraw/LIG Nex1 임베디드.md#^group=VrKSqIwlH7QfEL6YU8KUF]]
- 주파수의 두 배 이상 샘플링을 해야 한다.

- CCTV 카메라를 원격에서 동작시킬 때도 사용한다.
	- RS-485
### RS232c 트랜시버
- 3.3V

### 실습: printf가 SYSTICK 핸들러에 있는 경우
- SYSTICK
	- USART는 polling 방식으로 CPU가 블락이 걸리기 때문에 값이 밀린다.
	- 그래서 main으로 빼야 한다.

---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
