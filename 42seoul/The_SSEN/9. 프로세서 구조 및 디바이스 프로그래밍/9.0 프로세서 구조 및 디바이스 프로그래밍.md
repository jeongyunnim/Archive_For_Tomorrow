---
날짜: "2025-02-24"
넘버: 
태그: 프로그래밍/임베디드
출처: LIG Nex1 The SSEN Embedded SW School
강사: 홍영기
aliases:
---
### 날짜:  2025-02-24 08:57

### 태그: #프로그래밍/임베디드

>[!메모]
> 임베디드 소프트웨어는 해당 교재의 내용을 다 안다고 잘하는 것이 아니다.
> 여기에 있는 장치 중 아주 일부만 사용할 수도 있다.
> 전부 다 이해하려고 하지 말아라.
> 이해할 수 있는 만큼만 이해하자.
> 모든 걸 알고 개발하는 사람은 없다. 

- 복습
	- 가급적 수업 시간에 끝내자.
	- 남는 시간에는 실습을 해보기.
	- 책을 가급적 멀리하고 심화 실습을 해보면 좋다.
- 수업의 핵심
	- 장치들을 어떻게 설명하는지, 어떻게 요리하는지
	- 데이터시트를 어떤 걸 먼저 보고 설명하는지
	- 소스코드에서 어떤 걸 먼저 보고 설명하는지
	- 노하우를 배워서 처음 접하는 장치도 다룰 수 있게 되는 것이 목적이다.
### 원문
---
# 9.0 프로세서 구조 및 디바이스 프로그래밍

- 디바이스는 종류가 매우 많다.
- CAN 통신 -> SPI, I2C 이런 것들을 공부하고 심화학습의 영역으로

## ARM 
- 프로세서의 설계도([[반도체 IP(Intellectual Property)|IP]])를 제공하는 회사
- CORETEX-A
	- 고성능 프로세서
	- 프로젝트는 A를 사용해야 한다.
	- 리눅스는 M에서 구동되지 않는다.(ZYNQ -> CORETEX-A가 2개 탑재) 
	- MMU 탑재
- CORETEX-R
	- A와 가깝다.
-  CORETEX-M
	- 저가형 프로세서
	- 저전력
	- MPU는 옵션
- 아키텍처
	- v4부터 인기를 끌기 시작했다. 현재는 v7 아키텍처
### CORETEX-M 프로세서 특징
- v7아키텍처 기반
- [[Thumb-2]]명령어를 사용한다.
	- machine 전에 어셈블리 코드가 만들어진다.
	- thumb-2 어셈블리로 만들어진다.
	- 16, 32 비트로 구성된다.
- SIMD
	- advanced, 고급 연산을 지원
- 핸들러 및 스레드 모드
- ARMv6
	- 정렬되지 않은 액세스
- 메모리 보호장치
	- [[MPU]]
	- M4에는 있다.
- 고성능 버스(AHB-Lite)기반 ICode, Dcode 및 SYSTEM Bus 인터페이스
- APB, PPB 인터페이스 지원
### STM32
- STM32F429IDISCOVERY 보드
	- 429보드
	- 429칩이 붙어있는 보드이다.
- 상단부
	- 디버깅을 위한 부분
	- 디버깅 하드웨어가 일체형으로 들어있었기 때문에 USB로 PC에서 디버깅을 할 수 있었던 것이다.
- 하단부
	- 메인부분
	- 확장 헤더(확장 핀)
		- 전면부보다는 후면부에 연결하는 것이 수월하다.
	- LCD
		- FreeRTOS 수업 때 활용
#### ART Acclerator
- LCD 가속기
#### System
- power supply  1.2V internal regulator
	- 정류기
	- 전기를 공급해주는 장치
- Xtal oscillators
	- oscillator: 클럭 발진기, 클럭 공급기
	- Xtal: 크리스탈이라고 발음한다.
	- MCU안에 포함
- PLL
	- 위상고정제어루프
	- 클럭 구현 시 필요한 부품
- RTC
	- real time clock
	- 시계 + 알람
	- 달력의 기능도 RTC로 구현되어 있다.
- SysTick timer
	- stopwatch 같은 역할
- watchdog
	- 집 지키는 개.
	- 소프트웨어가 폭주를 할 때 잡아내는 장치
	- 소프트웨어와 하드웨어 오류를 잡아내는 장치
- I/O
	- GPIO 핀을 말한다.
- CRC
	- 디지털 데이터를 장거리에서 받았을 때, 오류가 났을 때를 대비하는 장치
	- 오류 검출, 복원 등의 기능을 한다.
- PWM
	- PWM timer라고 한다.
	- LCD의 밝기 조절
- [[DMA]]
	- A배열의 데이터를 B배열로 옮길 때 DMA를 사용하여 옮길 수 있다.
	- 데이터 복사를 빠르게 하고 싶을 때 사용한다.
- RNG
	- 임의의 수를 만들어 낸다.
#### Connectivity
- LCD controller
	- LCD 모듈을 제어하려면 controller가 있어야 한다.
- SPI / I2C / I2S
	- 시리얼 방식의 통신 장치
	- **!= UART**
	- inter chip communication
- camera interface
	- 카메라 모듈이 없어서 배우지는 않는다.
	- 연결하면 쓸 수 있다.
- Ethernet MAC 10/100
	- 네트워크 모듈이 없어서 사용할 수는 없다. 
- CAN
	- 통신할 모듈이 없다.
- USB 2.0 OTG
	- host와 device로 나뉜다.
	- OTG controller에 의해 제어된다.
	- USB 커넥터가 있으면 메모리와의 관계에서 해당 보드가 host가 될 수 있다.
	- 이 보드에서는 커넥터를 제공하지 않는다.
- SDMMC
	- SD 카드 컨트롤러
	- 커넥터를 제공하지 않는다.
- USART, UART
	- MCU
	- SPI/I2C/I2S는 On board 통신이다. 
		- 보드 안에서 부품끼리만 이루어지는 통신
	- 보드to보드, 보드toPC 통신 시 사용
- SAI
	- Serial audio interface
	- 없다.
#### Analog
- ADC
- DAC
- 온도센서
#### Memory
- FLASH 메모리
	- 2Mb
	- 프로그램(코드)가 들어가는 영역
	- ROM의 성격을 가진다.
- SRAM
	- 변수 영역, 데이터가 들어가는 메모리
	- ROM/RAM
	- 256Kb
- [[DRAM]]
#### 프로세서
- **CPU != 프로세서**
	- 프로세서 안에 CPU가 들어있다.
- FPU
	- 실수 연산을 하는 프로세서
	- CPU는 실수 연산을 할 수 없다.
	- 배우지 않는다.
- **NVIC**
	- 인터럽트 제어 장치
	- nested vectored interrupt contoller
	- 프로세서 내부에 있다는 것을 잊지 말자.
- JTAG
	- 디버깅할 때 사용한다.
- Embedded Trace Macrocell
	- break point를 걸 때 사용
- MPU
	- 가상 메모리, 가상주소/물리주소를 처리해주는 장치
### CLOCK
- 반복적으로, 주기적으로 나타나는 방형파 신호
	- 방형파: square wave
- 거의 대부분의 장치들이 클럭이 들어가야 동작한다.
	- 동작을 위해 전원이 들어가고 클럭이 공급되어야 한다.
- clock.의 주기가 얼마인가?
	- 주파수의 단위 Hz로 이야기한다.
### SFR Map
- Special Function Register Map
- Memory Mapped I/O
	- 해당 주소를 통해 주변장치에 대한 레지스터를 설정해줄 수 있다.
- 각 장치들은 해당되어있는 BUS가 있다.
## CubeIDE 시작하기
- project 시작
- [ ] generate code를 no를 선택해서 하나하나 구현하기. 어마어마한 공부가 된다.
- generate code -> 필요없는 모듈이 있을 때 삭제/추가하기
	- Middleware and Software탭
![[Pasted image 20250224121656.png]]
- 사용하지 않는 장치를 제거하기
	- 코드를 직접 제거하거나, ioc 파일에서 설정 
	- DMA2D: LCD 전용 DMA
	- LTDC: LCD 제어기
![[Pasted image 20250224122031.png]]
![[Pasted image 20250224122147.png]]
- 오류가 났다.
	- 첫 번째 발생한 오류부터 해결하기
	- `{`, `}`하나 빠진 오류 등은 안내된 컴파일 오류의 위치와 실제 오류가 난 위치를 찾기 힘들다.
	- 한 줄 작성 -> 컴파일 -> 한 줄 작성...
	- undo를 실행하면서 컴파일을 해서 원인을 밝혀라
- 디버그 중 편집이 가능하다.
	- 디버그를 하자마자 실행버튼(`||>`)을 눌러봤자 오류난다.
- trace
	- step into: 안으로 들어가기
		- inline assembly는 안 들어갈 수도 있다.
	- step over: 현재 레벨의 지역에서 한 줄 진행
	- step return
### 주요 기능과 특징
- Eclipse 기반의 IDE
	- 컴파일 엔진 GCC(GNU Compiler Collection) 탑재
- STM32CubeMX 통합
- breakpoint
	- 6개 까지만 가능하다.
	- 디버깅 시 리셋 버튼을 누르면 breakpoint를 무시하고 실행된다.
- disassembly
- memory
	- 0x080000000
		- ROM의 시작 주소
		- 쓰기 불가능
		- 롬라이터 또는 특별한 모드를 들어가야 쓸 수 있다.
			- 전기적인 특성
	- 0x020000000
		- RAM의 시작 주소
- SFRs
	- 하드웨어 레지스터
		- 다른 종류의 하드웨어 입출력을 위한 저장공간이다.
		- 레지스터를 다룬다는 것은 하드웨어를 다루는 것이다.
	- 프로세서 레지스터
		- 컴퓨터의 프로세서 내에서 자료를 보관하는 기억장치
		- 하드웨어 레지스터와 다르다.

## 레지스터
- 32비트로 되어있다.
- 레지스터의 이름
	- R0..15
	- R13: SP
		- stack pointer
		- ARM에는 SP대신 PSP, MSP를 가리킨다.
	- R14: LR
		- Link Register
	- R15: PC
		- Program Counter
	- PSR, PRIMASK, FAULTMASK, BASEPRI, CONTROL
		- 인터럽트 등을 학습한 후에 배울 것이다.
### 범용 레지스터
- R0 - R12
- THUMB 명령에서는 R0 ~ R7 레지스터를 사용
- THUMB2 명령에서는 R0 ~ R12 레지스터를 사용
### SP
- 스택 메모리의 용도
	- 전달인자(argument)
	- 지역변수
	- **컨택스트**
	- 리턴 주소
	- 프레임 포인터
#### Context
- 함수를 호출했을 때, 전달한 인자는 함수 호출 후에도 값이 같아야 한다.
- 임의의 함수 호출 전
![[Pasted image 20250224153041.png]]
- 호출 후
![[Pasted image 20250224153118.png]]
- R4 부터는 함수 호출 전과 후가 바뀌면 안된다.
	- [ ] main 함수부터 적용 -> 프로세스 생명 주기 내 전체 적용? 
	- 바뀔 위험이 있을 시 백업을 해놓아야 한다.
- CONTEXT
	- 문맥 저장: 레지스터 저장
	- 문맥 복원: 레지스터 복원
#### Return address
![[Excalidraw/LIG Nex1 임베디드.md#^group=R8TSiDrw2SnEEaSIFxrzz]]
#### Frame Pointer(R7 또는 R11)
- [ ] 다시 한 번 밝혀내기
- RAM -> 192KB
	- 스택은 맨 끝 쪽에 있다.
```
0x2002FFFF | END
...        |
0x2002ffe0 | 어떤 함수
...        |
0x20000000 | BASE address
```
- R7을 백업한다.
	- 계속 덮어쓰이기 때문에 스택에 백업을 해놓는 것이다.
- [ ] 스택 메모리의 용도 5가지
### Stack PUSH
- push 라는 명령을 통해서 스택에 삽입한다.
- 프로그램 시작 지점을 보면 이렇다.
	- `PUSH {r7, lr}`
![[Pasted image 20250224161803.png]]
![[Pasted image 20250224161944.png]]
- 스택 위치를 가리키는 포인터
	- 가리키는 곳 다음 주소에 저장한다. (상위 -> 하위, 주소의 크기가가 큰 -> 작은)
	- **프로세서가 스택에 새 항목을 푸시할 때 스택 포인터를 감소시킨 다음 항목을 새 메모리 위치에 쓴다.**
	- 선 감소 후 저장
		- ARM의 경우
	- push 하고 난 후 스택포인터가 가리키는 곳에 데이터가 들어있다.
	- LR(R14)을 먼저 저장하고 R7을 저장한다.
	- `push {r7, lr}`와 `push {lr, r7}`은 같다.
	- 스택은 **32bit**(워드 단위)만 push가 가능하다.
	- Full Descending Stack
### Stack POP
- 이전 콜 스택에서 가리키던 SP로 돌아간다.
## 동작 모드
- 2개의 모드
	- thread mode, Handler mode
- 2개의 특권 레벨
	- 특권과 비특권
- CORETEX에서 제공하는 3가지 모드
	- CONTROL 레지스터에 저장되어 있다.
	- **Priviledge Thread(default)**
		- 특권
	- priviledge Handler
		- **Interrupt**는 이 모드에서 실행된다.
	- User Thread
		- 제공은 하지만, 잘 사용하지 않는다.
		- 없는 셈 쳐라. 
- 특권
	- 특권이 있으면 특정 레지스터 값을 쓸 수 있다.
	- 특권모드와 비특권 모드의 스택은 분리되어있다.
		- 하지만 어차피 비특권 모드는 안 쓰므로 하나만 있는 셈 치자.
### SP 레지스터
- SP는 둘 중 하나의 alias이다.
	- msp 또는 psp
- msp
	- main stack pointer
- psp
	- process stack pointer
### PC 레지스터
: Program Counter
- R15(PC)를 사용하여 명령어를 FETCH한다.
- 항상 32bit를 읽어오고, 32bit 메모리와 함께 동작하도록 설계되었다.
- [[Pipeline]]때문에 명령어를 FETCH 과 EXECUTE에는 시간 차가 있다.
- [ ] 교재 참고하여 그림 그리기
- 프로그램을 읽기 위한 레지스터
	- 자동 증가가 되는 유일한 레지스터(하드웨어적으로 구현)
	- I_HADDR을 타고 명령어를 읽는다.
	- 읽은 데이터는 I_HRDATA
### THUMB2
- 어셈블리 명령어
- ARM과 THUMB 명령어 세트가 있었다.
	- LEGACY Processor에서 사용
	- ARM7, ARM9, ARM11, CORTEX-A, CORTEX-R의 기본 명령어 세트
	- 고정 길이 명령어
		- ARM: 32비트 고정
		- THUMB: 16비트 고정
- THUMB2는 가변 길이 명령어다.
	- 2바이트, 4바이트가 섞여있다.
- CORETEX-M은 THUMB2만 지원한다.
- ARM Thumb에 비해 코드 밀도가 약 26% 향상된다.
- Thumb에 비해 성능도 25% 향상된다.
#### Thumb2는 왜 좋은가?
- ARM과 THUMB를 번갈아 사용하려면 상태를 전환해야 한다.
	- 교체하는 비용이 발생한다.
	- THUMB2는 상태 전환할 필요가 없다.
- 2바이트는 썸 / 4바이트는 썸투 / 둘 다 합해서 썸투
### [[Pipeline]]
- FETCH - DECODE - EXECUTE를 한 클럭마다 중첩하여 실행한다.
- 2클럭이 지나면 한 클럭 마다 명령이 하나 씩 수행된다.
- 
---
### 생각(파생된 질문/생각)

### 출처
- LIG Nex1 The SSEN Embedded SW School

### 연결 문서 (연결 이유)
