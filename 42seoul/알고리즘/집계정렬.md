> counting sort, 내부 정렬 방법 연구의 간단한 예.

- 최종적으로 정렬된 수열의 j번째 키가 j-1개의 다른 키보다 더 클 것이다.
	중복 값이 없는 수열에서 해당 요소보다 작은 값이 27개의 값이 있다고 가정하였을 때, 28번째 위치에 놓일 것이라는 것을 알 수 있다.
- 정렬 방식: 모든 키를 비교하여 자신 보다 작은 키가 몇 개인지를 세어야 한다.
	`1 <= i <= N` 에 대해서 (`1 <= j <= N` K_j를 K_i와 비교).
	K_a와 K_b를 비교한 후에 K_b와 K_a를 또 비교할 필요는 없으므로, 아래와 같이 최적화가 가능하다.
	`1 < i <= N` 에 대해서 (`1 <= j < i` K_j를 K_i와 비교).

- ### 알고리즘 C(비교 집계)
	- 알고리즘 시나리오
		- K_1 ... K_n을 기준으로 하여 R_1 ... R_n을 정렬한다.
		- 주어진 키 보다 작은 키의 개수를 세기 위하여 보조 표 COUNT\[1\]...COUNT\[N\]를 유지한다. 
		- 알고리즘이 끝난 후 COUNT\[j\] + 1은 R_j의 최종위치를 가리키게 된다.
	- 알고리즘 순서
		- **C1** : COUNT\[\] 0으로 초기화
		- **C2**: i = 0, 1, 2 ... N 까지 C3을 수행한다.
		- **C3** : j = 0, 1, 2 ... i - 1 까지 C4를 수행한다.
		- **C4** : K_i < K_j 이면 COUNT\[j\]를 1 증가한다. 그렇지 않으면  COUNT\[i\]를 1 증가시킨다.
	- 알고리즘 특징
		- 서로 다른 키쌍을 모두 비교하므로 N^2의 시간 복잡도를 가진다. 이 정렬 방법은 속력보다는 단순함에 치중된 정렬방식이다.

- ### 알고리즘 D(분포 집계)
	- 알고리즘 시나리오
		- 모든 키가 1 <= j <= K에 대한 범위 u <= K_j <= v의 정수라고 가정하고, R_1 ... R_N을 COUNT\[u\] ... COUNT\[v\]를 활용해서 정렬한다.
		- 알고리즘이 끝난 후 레코드들은 출력 영역 S_1 ... S_N에 적절한 순서로 옮겨진 상태가 된다.
	- 알고리즘 순서
		- **D1**: COUNT\[u\]에서 COUNT\[v\] 0으로 초기화.
		- **D2**: 0 <= j <= N 까지 **D3**을 수행한다 그후 **D4**로 간다.
		- **D3**: COUNT\[K_i\]의 값을 1 증가시킨다.
		- **D4**: 현재 COUNT\[i\]의 값은 i와 같은 키들의 개수 이므로, i = u+1, u+2... v에 대해 COUNT\[i\] <- COUNT\[i] + COUNT\[i - 1]로 설정한다.
		- **D5**: 현재 COUNT\[i]는 i보다 작거나 같은 키들의 개수이다. 특히 COUNT\[v]는 N이다. 단계 D6을 j = N, N-1, N-2에 대해 반복한다. 그런다음 알고리즘을 끝낸다.
		- **D6**: i <- COUNT\[K_j], S_1 <- R_j, COUNT\[K_j] <- i - 1로 설정한다.
	- 알고리즘 특징
		- 1956년 기수 정렬 기법들과 함꼐 쓸 목적으로 시워드가 개발한 알고리즘이다.
	- 프로그램 소요 시간
		- 13N+6A+5B-4
	![[Pasted image 20230808152329.png]]